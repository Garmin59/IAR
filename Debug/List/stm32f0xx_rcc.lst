###############################################################################
#
# IAR ANSI C/C++ Compiler V8.20.2.14835/W32 for ARM       27/Dec/2017  21:15:20
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Ilya\Projects\332 WS2811 hew year light\IAR\CMSIS\stm32f0xx_rcc.c
#    Command line =  
#        -f C:\Users\75BD~1\AppData\Local\Temp\EWAE99.tmp
#        ("D:\Ilya\Projects\332 WS2811 hew year
#        light\IAR\CMSIS\stm32f0xx_rcc.c" -D STM32F0XX -D STM32F051
#        --preprocess=c "D:\Ilya\Projects\332 WS2811 hew year
#        light\IAR\Debug\List" -lC "D:\Ilya\Projects\332 WS2811 hew year
#        light\IAR\Debug\List" -o "D:\Ilya\Projects\332 WS2811 hew year
#        light\IAR\Debug\Obj" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I "D:\Ilya\Projects\332 WS2811
#        hew year light\IAR\system\" -I "D:\Ilya\Projects\332 WS2811 hew year
#        light\IAR\project\" -I "D:\Ilya\Projects\332 WS2811 hew year
#        light\IAR\CMSIS\" -I "D:\Ilya\Projects\332 WS2811 hew year
#        light\IAR\CMSIS\inc\" -I "D:\Ilya\Projects\332 WS2811 hew year
#        light\IAR\" -Ol --use_c++_inline --relaxed_fp --source_encoding locale
#        --text_out locale)
#    Locale       =  Russian_RUS.1251
#    List file    =  
#        D:\Ilya\Projects\332 WS2811 hew year
#        light\IAR\Debug\List\stm32f0xx_rcc.lst
#    Object file  =  
#        D:\Ilya\Projects\332 WS2811 hew year
#        light\IAR\Debug\Obj\stm32f0xx_rcc.o
#
###############################################################################

D:\Ilya\Projects\332 WS2811 hew year light\IAR\CMSIS\stm32f0xx_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f0xx_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0RC1
      6            * @date    27-January-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Reset and clock control (RCC) peripheral:
      9            *           + Internal/external clocks, PLL, CSS and MCO configuration
     10            *           + System, AHB and APB busses clocks configuration
     11            *           + Peripheral clocks configuration
     12            *           + Interrupts and flags management
     13            *
     14           @verbatim
     15          
     16           ===============================================================================
     17                                  ##### RCC specific features #####
     18           ===============================================================================
     19              [..] After reset the device is running from HSI (8 MHz) with Flash 0 WS, 
     20                   all peripherals are off except internal SRAM, Flash and SWD.
     21                   (#) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
     22                       all peripherals mapped on these busses are running at HSI speed.
     23                   (#) The clock for all peripherals is switched off, except the SRAM and FLASH.
     24                   (#) All GPIOs are in input floating state, except the SWD pins which
     25                       are assigned to be used for debug purpose.
     26              [..] Once the device started from reset, the user application has to:
     27                   (#) Configure the clock source to be used to drive the System clock
     28                       (if the application needs higher frequency/performance)
     29                   (#) Configure the System clock frequency and Flash settings
     30                   (#) Configure the AHB and APB busses prescalers
     31                   (#) Enable the clock for the peripheral(s) to be used
     32                   (#) Configure the clock source(s) for peripherals which clocks are not
     33                       derived from the System clock (ADC, CEC, I2C, USART, RTC and IWDG)
     34          
     35           @endverbatim
     36            
     37            ******************************************************************************
     38            * @attention
     39            *
     40            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     41            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     42            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     43            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     44            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     45            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     46            *
     47            * FOR MORE INFORMATION PLEASE READ CAREFULLY THE LICENSE AGREEMENT FILE
     48            * LOCATED IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     49            *
     50            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     51            ******************************************************************************
     52            */
     53          
     54          /* Includes ------------------------------------------------------------------*/
     55          #include	"stm32f0xx_conf.h"			// конфигурация используемых функций CMSIS
     56          #include  "stm32f0xx_rcc.h"
     57          
     58          /** @addtogroup STM32F0xx_StdPeriph_Driver
     59            * @{
     60            */
     61          
     62          /** @defgroup RCC 
     63            * @brief RCC driver modules
     64            * @{
     65            */ 
     66          
     67          /* Private typedef -----------------------------------------------------------*/
     68          /* Private define ------------------------------------------------------------*/
     69          
     70          /* ---------------------- RCC registers mask -------------------------------- */
     71          /* RCC Flag Mask */
     72          #define FLAG_MASK                 ((uint8_t)0x1F)
     73          
     74          /* CR register byte 2 (Bits[23:16]) base address */
     75          #define CR_BYTE2_ADDRESS          ((uint32_t)0x40021002)
     76          
     77          /* CFGR register byte 3 (Bits[31:23]) base address */
     78          #define CFGR_BYTE3_ADDRESS        ((uint32_t)0x40021007)
     79          
     80          /* CIR register byte 1 (Bits[15:8]) base address */
     81          #define CIR_BYTE1_ADDRESS         ((uint32_t)0x40021009)
     82          
     83          /* CIR register byte 2 (Bits[23:16]) base address */
     84          #define CIR_BYTE2_ADDRESS         ((uint32_t)0x4002100A)
     85          
     86          /* Private macro -------------------------------------------------------------*/
     87          /* Private variables ---------------------------------------------------------*/

   \                                 In section .data, align 4
     88          static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     APBAHBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x06 0x07    
   \              0x08 0x09    
     89          
     90          /* Private function prototypes -----------------------------------------------*/
     91          /* Private functions ---------------------------------------------------------*/
     92          
     93          /** @defgroup RCC_Private_Functions
     94            * @{
     95            */
     96          
     97          /** @defgroup RCC_Group1 Internal and external clocks, PLL, CSS and MCO configuration functions
     98           *  @brief   Internal and external clocks, PLL, CSS and MCO configuration functions 
     99           *
    100          @verbatim
    101           ===============================================================================
    102           ##### Internal-external clocks, PLL, CSS and MCO configuration functions #####
    103           ===============================================================================
    104              [..] This section provides functions allowing to configure the internal/external clocks,
    105                   PLL, CSS and MCO.
    106                   (#) HSI (high-speed internal), 8 MHz factory-trimmed RC used directly 
    107                       or through the PLL as System clock source.
    108                       The HSI clock can be used also to clock the USART, I2C and CEC peripherals.
    109                   (#) HSI14 (high-speed internal for ADC), 14 MHz factory-trimmed RC used to clock
    110                       the ADC peripheral.
    111                   (#) LSI (low-speed internal), 40 KHz low consumption RC used as IWDG and/or RTC
    112                       clock source.
    113                   (#) HSE (high-speed external), 4 to 32 MHz crystal oscillator used directly or
    114                       through the PLL as System clock source. Can be used also as RTC clock source.
    115                   (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source. 
    116                       LSE can be used also to clock the USART and CEC peripherals.   
    117                   (#) PLL (clocked by HSI or HSE), for System clock.
    118                   (#) CSS (Clock security system), once enabled and if a HSE clock failure occurs 
    119                       (HSE used directly or through PLL as System clock source), the System clock
    120                       is automatically switched to HSI and an interrupt is generated if enabled. 
    121                       The interrupt is linked to the Cortex-M0 NMI (Non-Maskable Interrupt) 
    122                       exception vector.   
    123                   (#) MCO (microcontroller clock output), used to output SYSCLK, HSI, HSI14, HSE, 
    124                       PLL clock on PA8 pin.
    125          
    126          @endverbatim
    127            * @{
    128            */
    129          
    130          /**
    131            * @brief  Resets the RCC clock configuration to the default reset state.
    132            * @note   The default reset state of the clock configuration is given below:
    133            * @note      HSI ON and used as system clock source 
    134            * @note      HSI14, HSE and PLL OFF
    135            * @note      AHB, APB prescaler set to 1.
    136            * @note      CSS and MCO OFF
    137            * @note      All interrupts disabled
    138            * @note   However, this function doesn't modify the configuration of the
    139            * @note      Peripheral clocks
    140            * @note      LSI, LSE and RTC clocks
    141            * @param  None
    142            * @retval None
    143            */

   \                                 In section .text, align 2, keep-with-next
    144          void RCC_DeInit(void)
    145          {
    146            /* Set HSION bit */
    147            RCC->CR |= (uint32_t)0x00000001;
   \                     RCC_DeInit: (+1)
   \   00000000   0x....             LDR      R0,??DataTable8  ;; 0x40021000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x4301             ORRS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable8  ;; 0x40021000
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    148          
    149            /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
    150            RCC->CFGR &= (uint32_t)0xF8FFB80C;
   \   0000000C   0x....             LDR      R0,??DataTable8_1  ;; 0x40021004
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x....             LDR      R1,??DataTable8_2  ;; 0xf8ffb80c
   \   00000012   0x4001             ANDS     R1,R1,R0
   \   00000014   0x....             LDR      R0,??DataTable8_1  ;; 0x40021004
   \   00000016   0x6001             STR      R1,[R0, #+0]
    151            
    152            /* Reset HSEON, CSSON and PLLON bits */
    153            RCC->CR &= (uint32_t)0xFEF6FFFF;
   \   00000018   0x....             LDR      R0,??DataTable8  ;; 0x40021000
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x....             LDR      R1,??DataTable8_3  ;; 0xfef6ffff
   \   0000001E   0x4001             ANDS     R1,R1,R0
   \   00000020   0x....             LDR      R0,??DataTable8  ;; 0x40021000
   \   00000022   0x6001             STR      R1,[R0, #+0]
    154          
    155            /* Reset HSEBYP bit */
    156            RCC->CR &= (uint32_t)0xFFFBFFFF;
   \   00000024   0x....             LDR      R0,??DataTable8  ;; 0x40021000
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x....             LDR      R1,??DataTable8_4  ;; 0xfffbffff
   \   0000002A   0x4001             ANDS     R1,R1,R0
   \   0000002C   0x....             LDR      R0,??DataTable8  ;; 0x40021000
   \   0000002E   0x6001             STR      R1,[R0, #+0]
    157          
    158            /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
    159            RCC->CFGR &= (uint32_t)0xFFC0FFFF;
   \   00000030   0x....             LDR      R0,??DataTable8_1  ;; 0x40021004
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x....             LDR      R1,??DataTable9  ;; 0xffc0ffff
   \   00000036   0x4001             ANDS     R1,R1,R0
   \   00000038   0x....             LDR      R0,??DataTable8_1  ;; 0x40021004
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    160          
    161            /* Reset PREDIV1[3:0] bits */
    162            RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
   \   0000003C   0x....             LDR      R0,??DataTable9_1  ;; 0x4002102c
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x210F             MOVS     R1,#+15
   \   00000042   0x4388             BICS     R0,R0,R1
   \   00000044   0x....             LDR      R1,??DataTable9_1  ;; 0x4002102c
   \   00000046   0x6008             STR      R0,[R1, #+0]
    163          
    164            /* Reset USARTSW[1:0], I2CSW, CECSW and ADCSW bits */
    165            RCC->CFGR3 &= (uint32_t)0xFFFFFEAC;
   \   00000048   0x....             LDR      R0,??DataTable9_2  ;; 0x40021030
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x....             LDR      R1,??DataTable9_3  ;; 0xfffffeac
   \   0000004E   0x4001             ANDS     R1,R1,R0
   \   00000050   0x....             LDR      R0,??DataTable9_2  ;; 0x40021030
   \   00000052   0x6001             STR      R1,[R0, #+0]
    166            
    167            /* Reset HSI14 bit */
    168            RCC->CR2 &= (uint32_t)0xFFFFFFFE;
   \   00000054   0x....             LDR      R0,??DataTable9_4  ;; 0x40021034
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x4388             BICS     R0,R0,R1
   \   0000005C   0x....             LDR      R1,??DataTable9_4  ;; 0x40021034
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    169          
    170            /* Disable all interrupts */
    171            RCC->CIR = 0x00000000;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x....             LDR      R1,??DataTable9_5  ;; 0x40021008
   \   00000064   0x6008             STR      R0,[R1, #+0]
    172          }
   \   00000066   0x4770             BX       LR               ;; return
    173          
    174          /**
    175            * @brief  Configures the External High Speed oscillator (HSE).
    176            * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
    177            *           software should wait on HSERDY flag to be set indicating that HSE clock
    178            *           is stable and can be used to clock the PLL and/or system clock.
    179            *  @note    HSE state can not be changed if it is used directly or through the
    180            *           PLL as system clock. In this case, you have to select another source
    181            *           of the system clock then change the HSE state (ex. disable it).
    182            *  @note    The HSE is stopped by hardware when entering STOP and STANDBY modes.
    183            * @note   This function resets the CSSON bit, so if the Clock security system(CSS)
    184            *         was previously enabled you have to enable it again after calling this
    185            *         function.
    186            * @param RCC_HSE: specifies the new state of the HSE.
    187            *   This parameter can be one of the following values:
    188            *     @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
    189            *                       6 HSE oscillator clock cycles.
    190            *     @arg RCC_HSE_ON: turn ON the HSE oscillator
    191            *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
    192            * @retval None
    193            */

   \                                 In section .text, align 2, keep-with-next
    194          void RCC_HSEConfig(uint8_t RCC_HSE)
    195          {
   \                     RCC_HSEConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    196            /* Check the parameters */
    197            assert_param(IS_RCC_HSE(RCC_HSE));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00B             BEQ      ??RCC_HSEConfig_0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD007             BEQ      ??RCC_HSEConfig_0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0x2805             CMP      R0,#+5
   \   0000001A   0xD003             BEQ      ??RCC_HSEConfig_0
   \   0000001C   0x21C5             MOVS     R1,#+197
   \   0000001E   0x....             LDR      R0,??DataTable9_6
   \   00000020   0x.... 0x....      BL       assert_failed
    198          
    199            /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
    200            *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
   \                     ??RCC_HSEConfig_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x....             LDR      R1,??DataTable9_7  ;; 0x40021002
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    201          
    202            /* Set the new HSE configuration -------------------------------------------*/
    203            *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
   \   0000002A   0x....             LDR      R0,??DataTable9_7  ;; 0x40021002
   \   0000002C   0x7004             STRB     R4,[R0, #+0]
    204          
    205          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    206          
    207          /**
    208            * @brief  Waits for HSE start-up.
    209            * @note   This function waits on HSERDY flag to be set and return SUCCESS if 
    210            *         this flag is set, otherwise returns ERROR if the timeout is reached 
    211            *         and this flag is not set. The timeout value is defined by the constant
    212            *         HSE_STARTUP_TIMEOUT in stm32f0xx.h file. You can tailor it depending
    213            *         on the HSE crystal used in your application.
    214            *         - The HSE is stopped by hardware when entering STOP and STANDBY modes.
    215            * @param  None
    216            * @retval An ErrorStatus enumeration value:
    217            *          - SUCCESS: HSE oscillator is stable and ready to use
    218            *          - ERROR: HSE oscillator not yet ready
    219            */

   \                                 In section .text, align 2, keep-with-next
    220          ErrorStatus RCC_WaitForHSEStartUp(void)
    221          {
   \                     RCC_WaitForHSEStartUp: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    222            __IO uint32_t StartUpCounter = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    223            ErrorStatus status = ERROR;
   \   00000006   0x2000             MOVS     R0,#+0
    224            FlagStatus HSEStatus = RESET;
   \   00000008   0x2000             MOVS     R0,#+0
    225            
    226            /* Wait till HSE is ready and if timeout is reached exit */
    227            do
    228            {
    229              HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
   \                     ??RCC_WaitForHSEStartUp_0: (+1)
   \   0000000A   0x2011             MOVS     R0,#+17
   \   0000000C   0x.... 0x....      BL       RCC_GetFlagStatus
    230              StartUpCounter++;  
   \   00000010   0x9900             LDR      R1,[SP, #+0]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x9100             STR      R1,[SP, #+0]
    231            } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0x22A0             MOVS     R2,#+160
   \   0000001A   0x00D2             LSLS     R2,R2,#+3        ;; #+1280
   \   0000001C   0x4291             CMP      R1,R2
   \   0000001E   0xD002             BEQ      ??RCC_WaitForHSEStartUp_1
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD0F1             BEQ      ??RCC_WaitForHSEStartUp_0
    232            
    233            if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
   \                     ??RCC_WaitForHSEStartUp_1: (+1)
   \   00000026   0x2011             MOVS     R0,#+17
   \   00000028   0x.... 0x....      BL       RCC_GetFlagStatus
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD001             BEQ      ??RCC_WaitForHSEStartUp_2
    234            {
    235              status = SUCCESS;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE000             B        ??RCC_WaitForHSEStartUp_3
    236            }
    237            else
    238            {
    239              status = ERROR;
   \                     ??RCC_WaitForHSEStartUp_2: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
    240            }  
    241            return (status);
   \                     ??RCC_WaitForHSEStartUp_3: (+1)
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0xBD02             POP      {R1,PC}          ;; return
    242          }
    243          
    244          /**
    245            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    246            * @note   The calibration is used to compensate for the variations in voltage
    247            *         and temperature that influence the frequency of the internal HSI RC.
    248            *         Refer to the Application Note AN3300 for more details on how to  
    249            *         calibrate the HSI.
    250            * @param  HSICalibrationValue: specifies the HSI calibration trimming value.
    251            *         This parameter must be a number between 0 and 0x1F.
    252            * @retval None
    253            */

   \                                 In section .text, align 2, keep-with-next
    254          void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
    255          {
   \                     RCC_AdjustHSICalibrationValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    256            uint32_t tmpreg = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    257            
    258            /* Check the parameters */
    259            assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x2820             CMP      R0,#+32
   \   0000000C   0xDB04             BLT      ??RCC_AdjustHSICalibrationValue_0
   \   0000000E   0x21FF             MOVS     R1,#+255
   \   00000010   0x1D09             ADDS     R1,R1,#+4        ;; #+259
   \   00000012   0x....             LDR      R0,??DataTable9_6
   \   00000014   0x.... 0x....      BL       assert_failed
    260            
    261            tmpreg = RCC->CR;
   \                     ??RCC_AdjustHSICalibrationValue_0: (+1)
   \   00000018   0x....             LDR      R0,??DataTable8  ;; 0x40021000
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
    262            
    263            /* Clear HSITRIM[4:0] bits */
    264            tmpreg &= ~RCC_CR_HSITRIM;
   \   0000001C   0x21F8             MOVS     R1,#+248
   \   0000001E   0x4388             BICS     R0,R0,R1
    265            
    266            /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
    267            tmpreg |= (uint32_t)HSICalibrationValue << 3;
   \   00000020   0xB2E4             UXTB     R4,R4
   \   00000022   0x00E1             LSLS     R1,R4,#+3
   \   00000024   0x4301             ORRS     R1,R1,R0
    268          
    269            /* Store the new value */
    270            RCC->CR = tmpreg;
   \   00000026   0x....             LDR      R0,??DataTable8  ;; 0x40021000
   \   00000028   0x6001             STR      R1,[R0, #+0]
    271          }
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    272          
    273          /**
    274            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    275            * @note     After enabling the HSI, the application software should wait on 
    276            *           HSIRDY flag to be set indicating that HSI clock is stable and can
    277            *           be used to clock the PLL and/or system clock.
    278            * @note     HSI can not be stopped if it is used directly or through the PLL
    279            *           as system clock. In this case, you have to select another source 
    280            *           of the system clock then stop the HSI.
    281            * @note     The HSI is stopped by hardware when entering STOP and STANDBY modes.
    282            * @param  NewState: new state of the HSI.
    283            *         This parameter can be: ENABLE or DISABLE.
    284            * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
    285            *         clock cycles.
    286            * @retval None
    287            */

   \                                 In section .text, align 2, keep-with-next
    288          void RCC_HSICmd(FunctionalState NewState)
    289          {
   \                     RCC_HSICmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    290            /* Check the parameters */
    291            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ      ??RCC_HSICmd_0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD004             BEQ      ??RCC_HSICmd_0
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x3124             ADDS     R1,R1,#+36       ;; #+291
   \   00000018   0x....             LDR      R0,??DataTable9_6
   \   0000001A   0x.... 0x....      BL       assert_failed
    292            
    293            if (NewState != DISABLE)
   \                     ??RCC_HSICmd_0: (+1)
   \   0000001E   0xB2E4             UXTB     R4,R4
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD006             BEQ      ??RCC_HSICmd_1
    294            {
    295              RCC->CR |= RCC_CR_HSION;
   \   00000024   0x....             LDR      R0,??DataTable8  ;; 0x40021000
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x4301             ORRS     R1,R1,R0
   \   0000002C   0x....             LDR      R0,??DataTable8  ;; 0x40021000
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   \   00000030   0xE005             B        ??RCC_HSICmd_2
    296            }
    297            else
    298            {
    299              RCC->CR &= ~RCC_CR_HSION;
   \                     ??RCC_HSICmd_1: (+1)
   \   00000032   0x....             LDR      R0,??DataTable8  ;; 0x40021000
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x4388             BICS     R0,R0,R1
   \   0000003A   0x....             LDR      R1,??DataTable8  ;; 0x40021000
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    300            }
    301          }
   \                     ??RCC_HSICmd_2: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    302          
    303          /**
    304            * @brief  Adjusts the Internal High Speed oscillator for ADC (HSI14) 
    305            *         calibration value.
    306            * @note   The calibration is used to compensate for the variations in voltage
    307            *         and temperature that influence the frequency of the internal HSI RC.
    308            *         Refer to the Application Note AN3300 for more details on how to  
    309            *         calibrate the HSI14.
    310            * @param  HSI14CalibrationValue: specifies the HSI14 calibration trimming value.
    311            *         This parameter must be a number between 0 and 0x1F.
    312            * @retval None
    313            */

   \                                 In section .text, align 2, keep-with-next
    314          void RCC_AdjustHSI14CalibrationValue(uint8_t HSI14CalibrationValue)
    315          {
   \                     RCC_AdjustHSI14CalibrationValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    316            uint32_t tmpreg = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    317            
    318            /* Check the parameters */
    319            assert_param(IS_RCC_HSI14_CALIBRATION_VALUE(HSI14CalibrationValue));
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x2820             CMP      R0,#+32
   \   0000000C   0xDB04             BLT      ??RCC_AdjustHSI14CalibrationValue_0
   \   0000000E   0x21FF             MOVS     R1,#+255
   \   00000010   0x3140             ADDS     R1,R1,#+64       ;; #+319
   \   00000012   0x....             LDR      R0,??DataTable9_6
   \   00000014   0x.... 0x....      BL       assert_failed
    320            
    321            tmpreg = RCC->CR2;
   \                     ??RCC_AdjustHSI14CalibrationValue_0: (+1)
   \   00000018   0x....             LDR      R0,??DataTable9_4  ;; 0x40021034
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
    322            
    323            /* Clear HSI14TRIM[4:0] bits */
    324            tmpreg &= ~RCC_CR2_HSI14TRIM;
   \   0000001C   0x21F8             MOVS     R1,#+248
   \   0000001E   0x4388             BICS     R0,R0,R1
    325            
    326            /* Set the HSITRIM14[4:0] bits according to HSI14CalibrationValue value */
    327            tmpreg |= (uint32_t)HSI14CalibrationValue << 3;
   \   00000020   0xB2E4             UXTB     R4,R4
   \   00000022   0x00E1             LSLS     R1,R4,#+3
   \   00000024   0x4301             ORRS     R1,R1,R0
    328          
    329            /* Store the new value */
    330            RCC->CR2 = tmpreg;
   \   00000026   0x....             LDR      R0,??DataTable9_4  ;; 0x40021034
   \   00000028   0x6001             STR      R1,[R0, #+0]
    331          }
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    332          
    333          /**
    334            * @brief  Enables or disables the Internal High Speed oscillator for ADC (HSI14).
    335            * @note     After enabling the HSI14, the application software should wait on 
    336            *           HSIRDY flag to be set indicating that HSI clock is stable and can
    337            *           be used to clock the ADC.
    338            * @note     The HSI14 is stopped by hardware when entering STOP and STANDBY modes.
    339            * @param  NewState: new state of the HSI14.
    340            *         This parameter can be: ENABLE or DISABLE.
    341            * @note   When the HSI14 is stopped, HSI14RDY flag goes low after 6 HSI14 oscillator
    342            *         clock cycles.
    343            * @retval None
    344            */

   \                                 In section .text, align 2, keep-with-next
    345          void RCC_HSI14Cmd(FunctionalState NewState)
    346          {
   \                     RCC_HSI14Cmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    347            /* Check the parameters */
    348            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ      ??RCC_HSI14Cmd_0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD004             BEQ      ??RCC_HSI14Cmd_0
   \   00000014   0x21AE             MOVS     R1,#+174
   \   00000016   0x0049             LSLS     R1,R1,#+1        ;; #+348
   \   00000018   0x....             LDR      R0,??DataTable9_6
   \   0000001A   0x.... 0x....      BL       assert_failed
    349            
    350            if (NewState != DISABLE)
   \                     ??RCC_HSI14Cmd_0: (+1)
   \   0000001E   0xB2E4             UXTB     R4,R4
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD006             BEQ      ??RCC_HSI14Cmd_1
    351            {
    352              RCC->CR2 |= RCC_CR2_HSI14ON;
   \   00000024   0x....             LDR      R0,??DataTable9_4  ;; 0x40021034
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x4301             ORRS     R1,R1,R0
   \   0000002C   0x....             LDR      R0,??DataTable9_4  ;; 0x40021034
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   \   00000030   0xE005             B        ??RCC_HSI14Cmd_2
    353            }
    354            else
    355            {
    356              RCC->CR2 &= ~RCC_CR2_HSI14ON;
   \                     ??RCC_HSI14Cmd_1: (+1)
   \   00000032   0x....             LDR      R0,??DataTable9_4  ;; 0x40021034
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x4388             BICS     R0,R0,R1
   \   0000003A   0x....             LDR      R1,??DataTable9_4  ;; 0x40021034
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    357            }
    358          }
   \                     ??RCC_HSI14Cmd_2: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    359          
    360          /**
    361            * @brief  Enables or disables the Internal High Speed oscillator request from ADC.
    362            * @param  NewState: new state of the HSI14 ADC request.
    363            *         This parameter can be: ENABLE or DISABLE.
    364            * @retval None
    365            */

   \                                 In section .text, align 2, keep-with-next
    366          void RCC_HSI14ADCRequestCmd(FunctionalState NewState)
    367          {
   \                     RCC_HSI14ADCRequestCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    368            /* Check the parameters */
    369            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ      ??RCC_HSI14ADCRequestCmd_0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD004             BEQ      ??RCC_HSI14ADCRequestCmd_0
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x3172             ADDS     R1,R1,#+114      ;; #+369
   \   00000018   0x....             LDR      R0,??DataTable9_6
   \   0000001A   0x.... 0x....      BL       assert_failed
    370            
    371            if (NewState != DISABLE)
   \                     ??RCC_HSI14ADCRequestCmd_0: (+1)
   \   0000001E   0xB2E4             UXTB     R4,R4
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD006             BEQ      ??RCC_HSI14ADCRequestCmd_1
    372            {
    373              RCC->CR2 &= ~RCC_CR2_HSI14DIS;
   \   00000024   0x....             LDR      R0,??DataTable9_4  ;; 0x40021034
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x4388             BICS     R0,R0,R1
   \   0000002C   0x....             LDR      R1,??DataTable9_4  ;; 0x40021034
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE005             B        ??RCC_HSI14ADCRequestCmd_2
    374            }
    375            else
    376            {
    377              RCC->CR2 |= RCC_CR2_HSI14DIS;
   \                     ??RCC_HSI14ADCRequestCmd_1: (+1)
   \   00000032   0x....             LDR      R0,??DataTable9_4  ;; 0x40021034
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x2104             MOVS     R1,#+4
   \   00000038   0x4301             ORRS     R1,R1,R0
   \   0000003A   0x....             LDR      R0,??DataTable9_4  ;; 0x40021034
   \   0000003C   0x6001             STR      R1,[R0, #+0]
    378            }
    379          }
   \                     ??RCC_HSI14ADCRequestCmd_2: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    380          
    381          /**
    382            * @brief  Configures the External Low Speed oscillator (LSE).
    383            * @note     As the LSE is in the Backup domain and write access is denied to this
    384            *           domain after reset, you have to enable write access using 
    385            *           PWR_BackupAccessCmd(ENABLE) function before to configure the LSE
    386            *           (to be done once after reset).
    387            * @note     After enabling the LSE (RCC_LSE_ON or RCC_LSE_Bypass), the application
    388            *           software should wait on LSERDY flag to be set indicating that LSE clock
    389            *           is stable and can be used to clock the RTC.
    390            * @param  RCC_LSE: specifies the new state of the LSE.
    391            *   This parameter can be one of the following values:
    392            *     @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
    393            *                       6 LSE oscillator clock cycles.
    394            *     @arg RCC_LSE_ON: turn ON the LSE oscillator
    395            *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
    396            * @retval None
    397            */

   \                                 In section .text, align 2, keep-with-next
    398          void RCC_LSEConfig(uint32_t RCC_LSE)
    399          {
   \                     RCC_LSEConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    400            /* Check the parameters */
    401            assert_param(IS_RCC_LSE(RCC_LSE));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD008             BEQ      ??RCC_LSEConfig_0
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD006             BEQ      ??RCC_LSEConfig_0
   \   0000000C   0x2C05             CMP      R4,#+5
   \   0000000E   0xD004             BEQ      ??RCC_LSEConfig_0
   \   00000010   0x21FF             MOVS     R1,#+255
   \   00000012   0x3192             ADDS     R1,R1,#+146      ;; #+401
   \   00000014   0x....             LDR      R0,??DataTable9_6
   \   00000016   0x.... 0x....      BL       assert_failed
    402          
    403            /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
    404            /* Reset LSEON bit */
    405            RCC->BDCR &= ~(RCC_BDCR_LSEON);
   \                     ??RCC_LSEConfig_0: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable14  ;; 0x40021020
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x4388             BICS     R0,R0,R1
   \   00000022   0x....             LDR      R1,??DataTable14  ;; 0x40021020
   \   00000024   0x6008             STR      R0,[R1, #+0]
    406          
    407            /* Reset LSEBYP bit */
    408            RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
   \   00000026   0x....             LDR      R0,??DataTable14  ;; 0x40021020
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x2104             MOVS     R1,#+4
   \   0000002C   0x4388             BICS     R0,R0,R1
   \   0000002E   0x....             LDR      R1,??DataTable14  ;; 0x40021020
   \   00000030   0x6008             STR      R0,[R1, #+0]
    409          
    410            /* Configure LSE */
    411            RCC->BDCR |= RCC_LSE;
   \   00000032   0x....             LDR      R0,??DataTable14  ;; 0x40021020
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x4304             ORRS     R4,R4,R0
   \   00000038   0x....             LDR      R0,??DataTable14  ;; 0x40021020
   \   0000003A   0x6004             STR      R4,[R0, #+0]
    412          }
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    413          
    414          /**
    415            * @brief  Configures the External Low Speed oscillator (LSE) drive capability.
    416            * @param  RCC_LSEDrive: specifies the new state of the LSE drive capability.
    417            *   This parameter can be one of the following values:
    418            *     @arg RCC_LSEDrive_Low: LSE oscillator low drive capability.
    419            *     @arg RCC_LSEDrive_MediumLow: LSE oscillator medium low drive capability.
    420            *     @arg RCC_LSEDrive_MediumHigh: LSE oscillator medium high drive capability.
    421            *     @arg RCC_LSEDrive_High: LSE oscillator high drive capability.
    422            * @retval None
    423            */

   \                                 In section .text, align 2, keep-with-next
    424          void RCC_LSEDriveConfig(uint32_t RCC_LSEDrive)
    425          {
   \                     RCC_LSEDriveConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    426            /* Check the parameters */
    427            assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD00A             BEQ      ??RCC_LSEDriveConfig_0
   \   00000008   0x2C08             CMP      R4,#+8
   \   0000000A   0xD008             BEQ      ??RCC_LSEDriveConfig_0
   \   0000000C   0x2C10             CMP      R4,#+16
   \   0000000E   0xD006             BEQ      ??RCC_LSEDriveConfig_0
   \   00000010   0x2C18             CMP      R4,#+24
   \   00000012   0xD004             BEQ      ??RCC_LSEDriveConfig_0
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x31AC             ADDS     R1,R1,#+172      ;; #+427
   \   00000018   0x....             LDR      R0,??DataTable9_6
   \   0000001A   0x.... 0x....      BL       assert_failed
    428            
    429            /* Clear LSEDRV[1:0] bits */
    430            RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
   \                     ??RCC_LSEDriveConfig_0: (+1)
   \   0000001E   0x....             LDR      R0,??DataTable14  ;; 0x40021020
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2118             MOVS     R1,#+24
   \   00000024   0x4388             BICS     R0,R0,R1
   \   00000026   0x....             LDR      R1,??DataTable14  ;; 0x40021020
   \   00000028   0x6008             STR      R0,[R1, #+0]
    431          
    432            /* Set the LSE Drive */
    433            RCC->BDCR |= RCC_LSEDrive;
   \   0000002A   0x....             LDR      R0,??DataTable14  ;; 0x40021020
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x4304             ORRS     R4,R4,R0
   \   00000030   0x....             LDR      R0,??DataTable14  ;; 0x40021020
   \   00000032   0x6004             STR      R4,[R0, #+0]
    434          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    435          
    436          /**
    437            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
    438            * @note     After enabling the LSI, the application software should wait on 
    439            *           LSIRDY flag to be set indicating that LSI clock is stable and can
    440            *           be used to clock the IWDG and/or the RTC.
    441            * @note     LSI can not be disabled if the IWDG is running.
    442            * @param  NewState: new state of the LSI.
    443            *         This parameter can be: ENABLE or DISABLE.
    444            * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
    445            *         clock cycles.
    446            * @retval None
    447            */

   \                                 In section .text, align 2, keep-with-next
    448          void RCC_LSICmd(FunctionalState NewState)
    449          {
   \                     RCC_LSICmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    450            /* Check the parameters */
    451            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ      ??RCC_LSICmd_0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD004             BEQ      ??RCC_LSICmd_0
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x31C4             ADDS     R1,R1,#+196      ;; #+451
   \   00000018   0x....             LDR      R0,??DataTable9_6
   \   0000001A   0x.... 0x....      BL       assert_failed
    452            
    453            if (NewState != DISABLE)
   \                     ??RCC_LSICmd_0: (+1)
   \   0000001E   0xB2E4             UXTB     R4,R4
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD006             BEQ      ??RCC_LSICmd_1
    454            {
    455              RCC->CSR |= RCC_CSR_LSION;
   \   00000024   0x....             LDR      R0,??DataTable17  ;; 0x40021024
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x4301             ORRS     R1,R1,R0
   \   0000002C   0x....             LDR      R0,??DataTable17  ;; 0x40021024
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   \   00000030   0xE005             B        ??RCC_LSICmd_2
    456            }
    457            else
    458            {
    459              RCC->CSR &= ~RCC_CSR_LSION;
   \                     ??RCC_LSICmd_1: (+1)
   \   00000032   0x....             LDR      R0,??DataTable17  ;; 0x40021024
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x4388             BICS     R0,R0,R1
   \   0000003A   0x....             LDR      R1,??DataTable17  ;; 0x40021024
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    460            }
    461          }
   \                     ??RCC_LSICmd_2: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    462          
    463          /**
    464            * @brief  Configures the PLL clock source and multiplication factor.
    465            * @note   This function must be used only when the PLL is disabled.
    466            *
    467            * @param  RCC_PLLSource: specifies the PLL entry clock source.
    468            *   This parameter can be one of the following values:
    469            *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock selected as PLL clock source
    470            *     @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock entry
    471            * @note   The minimum input clock frequency for PLL is 2 MHz (when using HSE as
    472            *         PLL source).
    473            *
    474            * @param  RCC_PLLMul: specifies the PLL multiplication factor, which drive the PLLVCO clock
    475            *         This parameter can be RCC_PLLMul_x where x:[2,16] 
    476            *
    477            * @retval None
    478            */

   \                                 In section .text, align 2, keep-with-next
    479          void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
    480          {
   \                     RCC_PLLConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    481            /* Check the parameters */
    482            assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD008             BEQ      ??RCC_PLLConfig_0
   \   0000000A   0x2080             MOVS     R0,#+128
   \   0000000C   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ      ??RCC_PLLConfig_0
   \   00000012   0x21F1             MOVS     R1,#+241
   \   00000014   0x0049             LSLS     R1,R1,#+1        ;; #+482
   \   00000016   0x....             LDR      R0,??DataTable17_1
   \   00000018   0x.... 0x....      BL       assert_failed
    483            assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
   \                     ??RCC_PLLConfig_0: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD03C             BEQ      ??RCC_PLLConfig_1
   \   00000020   0x2080             MOVS     R0,#+128
   \   00000022   0x02C0             LSLS     R0,R0,#+11       ;; #+262144
   \   00000024   0x4285             CMP      R5,R0
   \   00000026   0xD038             BEQ      ??RCC_PLLConfig_1
   \   00000028   0x2080             MOVS     R0,#+128
   \   0000002A   0x0300             LSLS     R0,R0,#+12       ;; #+524288
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD034             BEQ      ??RCC_PLLConfig_1
   \   00000030   0x20C0             MOVS     R0,#+192
   \   00000032   0x0300             LSLS     R0,R0,#+12       ;; #+786432
   \   00000034   0x4285             CMP      R5,R0
   \   00000036   0xD030             BEQ      ??RCC_PLLConfig_1
   \   00000038   0x2080             MOVS     R0,#+128
   \   0000003A   0x0340             LSLS     R0,R0,#+13       ;; #+1048576
   \   0000003C   0x4285             CMP      R5,R0
   \   0000003E   0xD02C             BEQ      ??RCC_PLLConfig_1
   \   00000040   0x20A0             MOVS     R0,#+160
   \   00000042   0x0340             LSLS     R0,R0,#+13       ;; #+1310720
   \   00000044   0x4285             CMP      R5,R0
   \   00000046   0xD028             BEQ      ??RCC_PLLConfig_1
   \   00000048   0x20C0             MOVS     R0,#+192
   \   0000004A   0x0340             LSLS     R0,R0,#+13       ;; #+1572864
   \   0000004C   0x4285             CMP      R5,R0
   \   0000004E   0xD024             BEQ      ??RCC_PLLConfig_1
   \   00000050   0x20E0             MOVS     R0,#+224
   \   00000052   0x0340             LSLS     R0,R0,#+13       ;; #+1835008
   \   00000054   0x4285             CMP      R5,R0
   \   00000056   0xD020             BEQ      ??RCC_PLLConfig_1
   \   00000058   0x2080             MOVS     R0,#+128
   \   0000005A   0x0380             LSLS     R0,R0,#+14       ;; #+2097152
   \   0000005C   0x4285             CMP      R5,R0
   \   0000005E   0xD01C             BEQ      ??RCC_PLLConfig_1
   \   00000060   0x2090             MOVS     R0,#+144
   \   00000062   0x0380             LSLS     R0,R0,#+14       ;; #+2359296
   \   00000064   0x4285             CMP      R5,R0
   \   00000066   0xD018             BEQ      ??RCC_PLLConfig_1
   \   00000068   0x20A0             MOVS     R0,#+160
   \   0000006A   0x0380             LSLS     R0,R0,#+14       ;; #+2621440
   \   0000006C   0x4285             CMP      R5,R0
   \   0000006E   0xD014             BEQ      ??RCC_PLLConfig_1
   \   00000070   0x20B0             MOVS     R0,#+176
   \   00000072   0x0380             LSLS     R0,R0,#+14       ;; #+2883584
   \   00000074   0x4285             CMP      R5,R0
   \   00000076   0xD010             BEQ      ??RCC_PLLConfig_1
   \   00000078   0x20C0             MOVS     R0,#+192
   \   0000007A   0x0380             LSLS     R0,R0,#+14       ;; #+3145728
   \   0000007C   0x4285             CMP      R5,R0
   \   0000007E   0xD00C             BEQ      ??RCC_PLLConfig_1
   \   00000080   0x20D0             MOVS     R0,#+208
   \   00000082   0x0380             LSLS     R0,R0,#+14       ;; #+3407872
   \   00000084   0x4285             CMP      R5,R0
   \   00000086   0xD008             BEQ      ??RCC_PLLConfig_1
   \   00000088   0x20E0             MOVS     R0,#+224
   \   0000008A   0x0380             LSLS     R0,R0,#+14       ;; #+3670016
   \   0000008C   0x4285             CMP      R5,R0
   \   0000008E   0xD004             BEQ      ??RCC_PLLConfig_1
   \   00000090   0x21FF             MOVS     R1,#+255
   \   00000092   0x31E4             ADDS     R1,R1,#+228      ;; #+483
   \   00000094   0x....             LDR      R0,??DataTable17_1
   \   00000096   0x.... 0x....      BL       assert_failed
    484          
    485            /* Clear PLL Source [16] and Multiplier [21:18] bits */
    486            RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
   \                     ??RCC_PLLConfig_1: (+1)
   \   0000009A   0x....             LDR      R0,??DataTable21  ;; 0x40021004
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x....             LDR      R1,??DataTable18  ;; 0xffc2ffff
   \   000000A0   0x4001             ANDS     R1,R1,R0
   \   000000A2   0x....             LDR      R0,??DataTable21  ;; 0x40021004
   \   000000A4   0x6001             STR      R1,[R0, #+0]
    487          
    488            /* Set the PLL Source and Multiplier */
    489            RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
   \   000000A6   0x....             LDR      R0,??DataTable21  ;; 0x40021004
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x4325             ORRS     R5,R5,R4
   \   000000AC   0x4305             ORRS     R5,R5,R0
   \   000000AE   0x....             LDR      R0,??DataTable21  ;; 0x40021004
   \   000000B0   0x6005             STR      R5,[R0, #+0]
    490          }
   \   000000B2   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    491          
    492          /**
    493            * @brief  Enables or disables the PLL.
    494            * @note   - After enabling the PLL, the application software should wait on 
    495            *           PLLRDY flag to be set indicating that PLL clock is stable and can
    496            *           be used as system clock source.
    497            *         - The PLL can not be disabled if it is used as system clock source
    498            *         - The PLL is disabled by hardware when entering STOP and STANDBY modes.
    499            * @param  NewState: new state of the PLL.
    500            *         This parameter can be: ENABLE or DISABLE.
    501            * @retval None
    502            */

   \                                 In section .text, align 2, keep-with-next
    503          void RCC_PLLCmd(FunctionalState NewState)
    504          {
   \                     RCC_PLLCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    505            /* Check the parameters */
    506            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ      ??RCC_PLLCmd_0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD004             BEQ      ??RCC_PLLCmd_0
   \   00000014   0x21FD             MOVS     R1,#+253
   \   00000016   0x0049             LSLS     R1,R1,#+1        ;; #+506
   \   00000018   0x....             LDR      R0,??DataTable17_1
   \   0000001A   0x.... 0x....      BL       assert_failed
    507            
    508            if (NewState != DISABLE)
   \                     ??RCC_PLLCmd_0: (+1)
   \   0000001E   0xB2E4             UXTB     R4,R4
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD007             BEQ      ??RCC_PLLCmd_1
    509            {
    510              RCC->CR |= RCC_CR_PLLON;
   \   00000024   0x....             LDR      R0,??DataTable21_1  ;; 0x40021000
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2180             MOVS     R1,#+128
   \   0000002A   0x0449             LSLS     R1,R1,#+17       ;; #+16777216
   \   0000002C   0x4301             ORRS     R1,R1,R0
   \   0000002E   0x....             LDR      R0,??DataTable21_1  ;; 0x40021000
   \   00000030   0x6001             STR      R1,[R0, #+0]
   \   00000032   0xE005             B        ??RCC_PLLCmd_2
    511            }
    512            else
    513            {
    514              RCC->CR &= ~RCC_CR_PLLON;
   \                     ??RCC_PLLCmd_1: (+1)
   \   00000034   0x....             LDR      R0,??DataTable21_1  ;; 0x40021000
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x....             LDR      R1,??DataTable19  ;; 0xfeffffff
   \   0000003A   0x4001             ANDS     R1,R1,R0
   \   0000003C   0x....             LDR      R0,??DataTable21_1  ;; 0x40021000
   \   0000003E   0x6001             STR      R1,[R0, #+0]
    515            }
    516          }
   \                     ??RCC_PLLCmd_2: (+1)
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    517          
    518          /**
    519            * @brief  Configures the PREDIV1 division factor.
    520            * @note   This function must be used only when the PLL is disabled.
    521            * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
    522            *         This parameter can be RCC_PREDIV1_Divx where x:[1,16]
    523            * @retval None
    524            */

   \                                 In section .text, align 2, keep-with-next
    525          void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div)
    526          {
   \                     RCC_PREDIV1Config: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    527            uint32_t tmpreg = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    528            
    529            /* Check the parameters */
    530            assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD021             BEQ      ??RCC_PREDIV1Config_0
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD01F             BEQ      ??RCC_PREDIV1Config_0
   \   0000000E   0x2C02             CMP      R4,#+2
   \   00000010   0xD01D             BEQ      ??RCC_PREDIV1Config_0
   \   00000012   0x2C03             CMP      R4,#+3
   \   00000014   0xD01B             BEQ      ??RCC_PREDIV1Config_0
   \   00000016   0x2C04             CMP      R4,#+4
   \   00000018   0xD019             BEQ      ??RCC_PREDIV1Config_0
   \   0000001A   0x2C05             CMP      R4,#+5
   \   0000001C   0xD017             BEQ      ??RCC_PREDIV1Config_0
   \   0000001E   0x2C06             CMP      R4,#+6
   \   00000020   0xD015             BEQ      ??RCC_PREDIV1Config_0
   \   00000022   0x2C07             CMP      R4,#+7
   \   00000024   0xD013             BEQ      ??RCC_PREDIV1Config_0
   \   00000026   0x2C08             CMP      R4,#+8
   \   00000028   0xD011             BEQ      ??RCC_PREDIV1Config_0
   \   0000002A   0x2C09             CMP      R4,#+9
   \   0000002C   0xD00F             BEQ      ??RCC_PREDIV1Config_0
   \   0000002E   0x2C0A             CMP      R4,#+10
   \   00000030   0xD00D             BEQ      ??RCC_PREDIV1Config_0
   \   00000032   0x2C0B             CMP      R4,#+11
   \   00000034   0xD00B             BEQ      ??RCC_PREDIV1Config_0
   \   00000036   0x2C0C             CMP      R4,#+12
   \   00000038   0xD009             BEQ      ??RCC_PREDIV1Config_0
   \   0000003A   0x2C0D             CMP      R4,#+13
   \   0000003C   0xD007             BEQ      ??RCC_PREDIV1Config_0
   \   0000003E   0x2C0E             CMP      R4,#+14
   \   00000040   0xD005             BEQ      ??RCC_PREDIV1Config_0
   \   00000042   0x2C0F             CMP      R4,#+15
   \   00000044   0xD003             BEQ      ??RCC_PREDIV1Config_0
   \   00000046   0x....             LDR      R1,??DataTable21_2  ;; 0x212
   \   00000048   0x....             LDR      R0,??DataTable17_1
   \   0000004A   0x.... 0x....      BL       assert_failed
    531          
    532            tmpreg = RCC->CFGR2;
   \                     ??RCC_PREDIV1Config_0: (+1)
   \   0000004E   0x....             LDR      R0,??DataTable22  ;; 0x4002102c
   \   00000050   0x6800             LDR      R0,[R0, #+0]
    533            /* Clear PREDIV1[3:0] bits */
    534            tmpreg &= ~(RCC_CFGR2_PREDIV1);
   \   00000052   0x210F             MOVS     R1,#+15
   \   00000054   0x4388             BICS     R0,R0,R1
    535            /* Set the PREDIV1 division factor */
    536            tmpreg |= RCC_PREDIV1_Div;
   \   00000056   0x4304             ORRS     R4,R4,R0
    537            /* Store the new value */
    538            RCC->CFGR2 = tmpreg;
   \   00000058   0x....             LDR      R0,??DataTable22  ;; 0x4002102c
   \   0000005A   0x6004             STR      R4,[R0, #+0]
    539          }
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    540          
    541          /**
    542            * @brief  Enables or disables the Clock Security System.
    543            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
    544            *         is automatically disabled and an interrupt is generated to inform the
    545            *         software about the failure (Clock Security System Interrupt, CSSI),
    546            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
    547            *         the Cortex-M0 NMI (Non-Maskable Interrupt) exception vector.
    548            * @param  NewState: new state of the Clock Security System.
    549            *         This parameter can be: ENABLE or DISABLE.
    550            * @retval None
    551            */

   \                                 In section .text, align 2, keep-with-next
    552          void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
    553          {
   \                     RCC_ClockSecuritySystemCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    554            /* Check the parameters */
    555            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD007             BEQ      ??RCC_ClockSecuritySystemCmd_0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD003             BEQ      ??RCC_ClockSecuritySystemCmd_0
   \   00000014   0x....             LDR      R1,??DataTable22_1  ;; 0x22b
   \   00000016   0x....             LDR      R0,??DataTable17_1
   \   00000018   0x.... 0x....      BL       assert_failed
    556            
    557            if (NewState != DISABLE)
   \                     ??RCC_ClockSecuritySystemCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD007             BEQ      ??RCC_ClockSecuritySystemCmd_1
    558            {
    559              RCC->CR |= RCC_CR_CSSON;
   \   00000022   0x....             LDR      R0,??DataTable21_1  ;; 0x40021000
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   0000002A   0x4301             ORRS     R1,R1,R0
   \   0000002C   0x....             LDR      R0,??DataTable21_1  ;; 0x40021000
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   \   00000030   0xE005             B        ??RCC_ClockSecuritySystemCmd_2
    560            }
    561            else
    562            {
    563              RCC->CR &= ~RCC_CR_CSSON;
   \                     ??RCC_ClockSecuritySystemCmd_1: (+1)
   \   00000032   0x....             LDR      R0,??DataTable21_1  ;; 0x40021000
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x....             LDR      R1,??DataTable22_2  ;; 0xfff7ffff
   \   00000038   0x4001             ANDS     R1,R1,R0
   \   0000003A   0x....             LDR      R0,??DataTable21_1  ;; 0x40021000
   \   0000003C   0x6001             STR      R1,[R0, #+0]
    564            }
    565          }
   \                     ??RCC_ClockSecuritySystemCmd_2: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    566          
    567          /**
    568            * @brief  Selects the clock source to output on MCO pin (PA8).
    569            * @note   PA8 should be configured in alternate function mode.
    570            * @param  RCC_MCOSource: specifies the clock source to output.
    571            *   This parameter can be one of the following values:
    572            *     @arg RCC_MCOSource_NoClock: No clock selected.
    573            *     @arg RCC_MCOSource_HSI14: HSI14 oscillator clock selected.
    574            *     @arg RCC_MCOSource_SYSCLK: System clock selected.
    575            *     @arg RCC_MCOSource_HSI: HSI oscillator clock selected.
    576            *     @arg RCC_MCOSource_HSE: HSE oscillator clock selected.
    577            *     @arg RCC_MCOSource_PLLCLK_Div2: PLL clock selected.
    578            * @retval None
    579            */

   \                                 In section .text, align 2, keep-with-next
    580          void RCC_MCOConfig(uint8_t RCC_MCOSource)
    581          {
   \                     RCC_MCOConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    582            /* Check the parameters */
    583            assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD017             BEQ      ??RCC_MCOConfig_0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD013             BEQ      ??RCC_MCOConfig_0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0x2804             CMP      R0,#+4
   \   0000001A   0xD00F             BEQ      ??RCC_MCOConfig_0
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x2805             CMP      R0,#+5
   \   00000022   0xD00B             BEQ      ??RCC_MCOConfig_0
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x2806             CMP      R0,#+6
   \   0000002A   0xD007             BEQ      ??RCC_MCOConfig_0
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xB2C0             UXTB     R0,R0
   \   00000030   0x2807             CMP      R0,#+7
   \   00000032   0xD003             BEQ      ??RCC_MCOConfig_0
   \   00000034   0x....             LDR      R1,??DataTable22_3  ;; 0x247
   \   00000036   0x....             LDR      R0,??DataTable17_1
   \   00000038   0x.... 0x....      BL       assert_failed
    584              
    585            /* Select MCO clock source and prescaler */
    586            *(__IO uint8_t *) CFGR_BYTE3_ADDRESS =  RCC_MCOSource;
   \                     ??RCC_MCOConfig_0: (+1)
   \   0000003C   0x....             LDR      R0,??DataTable22_4  ;; 0x40021007
   \   0000003E   0x7004             STRB     R4,[R0, #+0]
    587          }
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    588          
    589          /**
    590            * @}
    591            */
    592          
    593          /** @defgroup RCC_Group2 System AHB and APB busses clocks configuration functions
    594           *  @brief   System, AHB and APB busses clocks configuration functions
    595           *
    596          @verbatim
    597           ===============================================================================
    598               ##### System, AHB and APB busses clocks configuration functions #####
    599           ===============================================================================
    600          
    601              [..] This section provide functions allowing to configure the System, AHB and 
    602                   APB busses clocks.
    603                   (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
    604                       HSE and PLL.
    605                       The AHB clock (HCLK) is derived from System clock through configurable prescaler
    606                       and used to clock the CPU, memory and peripherals mapped on AHB bus (DMA and GPIO).
    607                       and APB (PCLK) clocks are derived from AHB clock through 
    608                       configurable prescalers and used to clock the peripherals mapped on these busses.
    609                       You can use "RCC_GetClocksFreq()" function to retrieve the frequencies of these clocks.
    610          
    611                   -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    612                       (+@) The ADC clock which is derived from HSI14 or APB (APB divided by a
    613                            programmable prescaler: 2 or 4).
    614                       (+@) The CEC clock which is derived from LSE or HSI divided by 244.
    615                       (+@) The I2C clock which is derived from HSI or system clock (SYSCLK).
    616                       (+@) The USART clock which is derived from HSI, system clock (SYSCLK), APB or LSE.
    617                       (+@) The RTC/LCD clock which is derived from the LSE, LSI or 2 MHz HSE_RTC (HSE
    618                            divided by a programmable prescaler).
    619                            The System clock (SYSCLK) frequency must be higher or equal to the RTC/LCD
    620                            clock frequency.
    621                       (+@) IWDG clock which is always the LSI clock.
    622                 
    623                   (#) The maximum frequency of the SYSCLK, HCLK and PCLK is 48 MHz.
    624                       Depending on the maximum frequency, the FLASH wait states (WS) should be 
    625                       adapted accordingly:
    626                  +--------------------------------------------- +
    627                  |  Wait states  |   HCLK clock frequency (MHz) |
    628                  |---------------|------------------------------|
    629                  |0WS(1CPU cycle)|       0 < HCLK <= 24         |
    630                  |---------------|------------------------------|
    631                  |1WS(2CPU cycle)|       24 < HCLK <= 48        |
    632                  +----------------------------------------------+
    633          
    634                   (#) After reset, the System clock source is the HSI (8 MHz) with 0 WS and 
    635                       prefetch is disabled.
    636            
    637              [..] It is recommended to use the following software sequences to tune the number
    638                   of wait states needed to access the Flash memory with the CPU frequency (HCLK).
    639                   (+) Increasing the CPU frequency
    640                   (++) Program the Flash Prefetch buffer, using "FLASH_PrefetchBufferCmd(ENABLE)" 
    641                        function
    642                   (++) Check that Flash Prefetch buffer activation is taken into account by 
    643                        reading FLASH_ACR using the FLASH_GetPrefetchBufferStatus() function
    644                   (++) Program Flash WS to 1, using "FLASH_SetLatency(FLASH_Latency_1)" function
    645                   (++) Check that the new number of WS is taken into account by reading FLASH_ACR
    646                   (++) Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
    647                   (++) If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
    648                   (++) Check that the new CPU clock source is taken into account by reading 
    649                        the clock source status, using "RCC_GetSYSCLKSource()" function 
    650                   (+) Decreasing the CPU frequency
    651                   (++) Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
    652                   (++) If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
    653                   (++) Check that the new CPU clock source is taken into account by reading 
    654                        the clock source status, using "RCC_GetSYSCLKSource()" function
    655                   (++) Program the new number of WS, using "FLASH_SetLatency()" function
    656                   (++) Check that the new number of WS is taken into account by reading FLASH_ACR
    657                   (++) Disable the Flash Prefetch buffer using "FLASH_PrefetchBufferCmd(DISABLE)" 
    658                        function
    659                   (++) Check that Flash Prefetch buffer deactivation is taken into account by reading FLASH_ACR
    660                        using the FLASH_GetPrefetchBufferStatus() function.
    661          
    662          @endverbatim
    663            * @{
    664            */
    665          
    666          /**
    667            * @brief  Configures the system clock (SYSCLK).
    668            * @note    The HSI is used (enabled by hardware) as system clock source after
    669            *           startup from Reset, wake-up from STOP and STANDBY mode, or in case
    670            *           of failure of the HSE used directly or indirectly as system clock
    671            *           (if the Clock Security System CSS is enabled).
    672            * @note     A switch from one clock source to another occurs only if the target
    673            *           clock source is ready (clock stable after startup delay or PLL locked). 
    674            *           If a clock source which is not yet ready is selected, the switch will
    675            *           occur when the clock source will be ready. 
    676            *           You can use RCC_GetSYSCLKSource() function to know which clock is
    677            *           currently used as system clock source.  
    678            * @param  RCC_SYSCLKSource: specifies the clock source used as system clock source 
    679            *   This parameter can be one of the following values:
    680            *     @arg RCC_SYSCLKSource_HSI:    HSI selected as system clock source
    681            *     @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
    682            *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
    683            * @retval None
    684            */

   \                                 In section .text, align 2, keep-with-next
    685          void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
    686          {
   \                     RCC_SYSCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    687            uint32_t tmpreg = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    688            
    689            /* Check the parameters */
    690            assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ      ??RCC_SYSCLKConfig_0
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD005             BEQ      ??RCC_SYSCLKConfig_0
   \   0000000E   0x2C02             CMP      R4,#+2
   \   00000010   0xD003             BEQ      ??RCC_SYSCLKConfig_0
   \   00000012   0x....             LDR      R1,??DataTable22_5  ;; 0x2b2
   \   00000014   0x....             LDR      R0,??DataTable17_1
   \   00000016   0x.... 0x....      BL       assert_failed
    691            
    692            tmpreg = RCC->CFGR;
   \                     ??RCC_SYSCLKConfig_0: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable21  ;; 0x40021004
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
    693            
    694            /* Clear SW[1:0] bits */
    695            tmpreg &= ~RCC_CFGR_SW;
   \   0000001E   0x2103             MOVS     R1,#+3
   \   00000020   0x4388             BICS     R0,R0,R1
    696            
    697            /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
    698            tmpreg |= RCC_SYSCLKSource;
   \   00000022   0x4304             ORRS     R4,R4,R0
    699            
    700            /* Store the new value */
    701            RCC->CFGR = tmpreg;
   \   00000024   0x....             LDR      R0,??DataTable21  ;; 0x40021004
   \   00000026   0x6004             STR      R4,[R0, #+0]
    702          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    703          
    704          /**
    705            * @brief  Returns the clock source used as system clock.
    706            * @param  None
    707            * @retval The clock source used as system clock. The returned value can be one 
    708            *         of the following values:
    709            *              - 0x00: HSI used as system clock
    710            *              - 0x04: HSE used as system clock  
    711            *              - 0x08: PLL used as system clock
    712            */

   \                                 In section .text, align 2, keep-with-next
    713          uint8_t RCC_GetSYSCLKSource(void)
    714          {
    715            return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
   \                     RCC_GetSYSCLKSource: (+1)
   \   00000000   0x....             LDR      R0,??DataTable21  ;; 0x40021004
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x200C             MOVS     R0,#+12
   \   00000006   0x4008             ANDS     R0,R0,R1
   \   00000008   0x4770             BX       LR               ;; return
    716          }
    717          
    718          /**
    719            * @brief  Configures the AHB clock (HCLK).
    720            * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
    721            *                     the system clock (SYSCLK).
    722            *   This parameter can be one of the following values:
    723            *     @arg RCC_SYSCLK_Div1:   AHB clock = SYSCLK
    724            *     @arg RCC_SYSCLK_Div2:   AHB clock = SYSCLK/2
    725            *     @arg RCC_SYSCLK_Div4:   AHB clock = SYSCLK/4
    726            *     @arg RCC_SYSCLK_Div8:   AHB clock = SYSCLK/8
    727            *     @arg RCC_SYSCLK_Div16:  AHB clock = SYSCLK/16
    728            *     @arg RCC_SYSCLK_Div64:  AHB clock = SYSCLK/64
    729            *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
    730            *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
    731            *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
    732            * @retval None
    733            */

   \                                 In section .text, align 2, keep-with-next
    734          void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
    735          {
   \                     RCC_HCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    736            uint32_t tmpreg = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    737            
    738            /* Check the parameters */
    739            assert_param(IS_RCC_HCLK(RCC_SYSCLK));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD013             BEQ      ??RCC_HCLKConfig_0
   \   0000000A   0x2C80             CMP      R4,#+128
   \   0000000C   0xD011             BEQ      ??RCC_HCLKConfig_0
   \   0000000E   0x2C90             CMP      R4,#+144
   \   00000010   0xD00F             BEQ      ??RCC_HCLKConfig_0
   \   00000012   0x2CA0             CMP      R4,#+160
   \   00000014   0xD00D             BEQ      ??RCC_HCLKConfig_0
   \   00000016   0x2CB0             CMP      R4,#+176
   \   00000018   0xD00B             BEQ      ??RCC_HCLKConfig_0
   \   0000001A   0x2CC0             CMP      R4,#+192
   \   0000001C   0xD009             BEQ      ??RCC_HCLKConfig_0
   \   0000001E   0x2CD0             CMP      R4,#+208
   \   00000020   0xD007             BEQ      ??RCC_HCLKConfig_0
   \   00000022   0x2CE0             CMP      R4,#+224
   \   00000024   0xD005             BEQ      ??RCC_HCLKConfig_0
   \   00000026   0x2CF0             CMP      R4,#+240
   \   00000028   0xD003             BEQ      ??RCC_HCLKConfig_0
   \   0000002A   0x....             LDR      R1,??DataTable22_6  ;; 0x2e3
   \   0000002C   0x....             LDR      R0,??DataTable17_1
   \   0000002E   0x.... 0x....      BL       assert_failed
    740            
    741            tmpreg = RCC->CFGR;
   \                     ??RCC_HCLKConfig_0: (+1)
   \   00000032   0x....             LDR      R0,??DataTable24  ;; 0x40021004
   \   00000034   0x6800             LDR      R0,[R0, #+0]
    742            
    743            /* Clear HPRE[3:0] bits */
    744            tmpreg &= ~RCC_CFGR_HPRE;
   \   00000036   0x21F0             MOVS     R1,#+240
   \   00000038   0x4388             BICS     R0,R0,R1
    745            
    746            /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
    747            tmpreg |= RCC_SYSCLK;
   \   0000003A   0x4304             ORRS     R4,R4,R0
    748            
    749            /* Store the new value */
    750            RCC->CFGR = tmpreg;
   \   0000003C   0x....             LDR      R0,??DataTable24  ;; 0x40021004
   \   0000003E   0x6004             STR      R4,[R0, #+0]
    751          }
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    752          
    753          /**
    754            * @brief  Configures the APB clock (PCLK).
    755            * @param  RCC_HCLK: defines the APB clock divider. This clock is derived from 
    756            *         the AHB clock (HCLK).
    757            *   This parameter can be one of the following values:
    758            *     @arg RCC_HCLK_Div1: APB clock = HCLK
    759            *     @arg RCC_HCLK_Div2: APB clock = HCLK/2
    760            *     @arg RCC_HCLK_Div4: APB clock = HCLK/4
    761            *     @arg RCC_HCLK_Div8: APB clock = HCLK/8
    762            *     @arg RCC_HCLK_Div16: APB clock = HCLK/16
    763            * @retval None
    764            */

   \                                 In section .text, align 2, keep-with-next
    765          void RCC_PCLKConfig(uint32_t RCC_HCLK)
    766          {
   \                     RCC_PCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    767            uint32_t tmpreg = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    768            
    769            /* Check the parameters */
    770            assert_param(IS_RCC_PCLK(RCC_HCLK));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD013             BEQ      ??RCC_PCLKConfig_0
   \   0000000A   0x2080             MOVS     R0,#+128
   \   0000000C   0x00C0             LSLS     R0,R0,#+3        ;; #+1024
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00F             BEQ      ??RCC_PCLKConfig_0
   \   00000012   0x20A0             MOVS     R0,#+160
   \   00000014   0x00C0             LSLS     R0,R0,#+3        ;; #+1280
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD00B             BEQ      ??RCC_PCLKConfig_0
   \   0000001A   0x20C0             MOVS     R0,#+192
   \   0000001C   0x00C0             LSLS     R0,R0,#+3        ;; #+1536
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD007             BEQ      ??RCC_PCLKConfig_0
   \   00000022   0x20E0             MOVS     R0,#+224
   \   00000024   0x00C0             LSLS     R0,R0,#+3        ;; #+1792
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD003             BEQ      ??RCC_PCLKConfig_0
   \   0000002A   0x....             LDR      R1,??DataTable23  ;; 0x302
   \   0000002C   0x....             LDR      R0,??DataTable23_1
   \   0000002E   0x.... 0x....      BL       assert_failed
    771            
    772            tmpreg = RCC->CFGR;
   \                     ??RCC_PCLKConfig_0: (+1)
   \   00000032   0x....             LDR      R0,??DataTable24  ;; 0x40021004
   \   00000034   0x6800             LDR      R0,[R0, #+0]
    773            
    774            /* Clear PPRE[2:0] bits */
    775            tmpreg &= ~RCC_CFGR_PPRE;
   \   00000036   0x....             LDR      R1,??DataTable23_2  ;; 0xfffff8ff
   \   00000038   0x4001             ANDS     R1,R1,R0
    776            
    777            /* Set PPRE[2:0] bits according to RCC_HCLK value */
    778            tmpreg |= RCC_HCLK;
   \   0000003A   0x430C             ORRS     R4,R4,R1
    779            
    780            /* Store the new value */
    781            RCC->CFGR = tmpreg;
   \   0000003C   0x....             LDR      R0,??DataTable24  ;; 0x40021004
   \   0000003E   0x6004             STR      R4,[R0, #+0]
    782          }
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    783          
    784          /**
    785            * @brief  Configures the ADC clock (ADCCLK).
    786            * @param  RCC_ADCCLK: defines the ADC clock source. This clock is derived 
    787            *         from the HSI14 or APB clock (PCLK).
    788            *         This parameter can be one of the following values:
    789            *             @arg RCC_ADCCLK_HSI14: ADC clock = HSI14 (14MHz)
    790            *             @arg RCC_ADCCLK_PCLK_Div2: ADC clock = PCLK/2
    791            *             @arg RCC_ADCCLK_PCLK_Div4: ADC clock = PCLK/4  
    792            * @retval None
    793            */

   \                                 In section .text, align 2, keep-with-next
    794          void RCC_ADCCLKConfig(uint32_t RCC_ADCCLK)
    795          { 
   \                     RCC_ADCCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    796            /* Check the parameters */
    797            assert_param(IS_RCC_ADCCLK(RCC_ADCCLK));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD00A             BEQ      ??RCC_ADCCLKConfig_0
   \   00000008   0x2080             MOVS     R0,#+128
   \   0000000A   0x0440             LSLS     R0,R0,#+17       ;; #+16777216
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD006             BEQ      ??RCC_ADCCLKConfig_0
   \   00000010   0x....             LDR      R0,??DataTable24_1  ;; 0x1004000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD003             BEQ      ??RCC_ADCCLKConfig_0
   \   00000016   0x....             LDR      R1,??DataTable24_2  ;; 0x31d
   \   00000018   0x....             LDR      R0,??DataTable23_1
   \   0000001A   0x.... 0x....      BL       assert_failed
    798          
    799            /* Clear ADCPRE bit */
    800            RCC->CFGR &= ~RCC_CFGR_ADCPRE;
   \                     ??RCC_ADCCLKConfig_0: (+1)
   \   0000001E   0x....             LDR      R0,??DataTable21  ;; 0x40021004
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x....             LDR      R1,??DataTable24_3  ;; 0xffffbfff
   \   00000024   0x4001             ANDS     R1,R1,R0
   \   00000026   0x....             LDR      R0,??DataTable21  ;; 0x40021004
   \   00000028   0x6001             STR      R1,[R0, #+0]
    801            /* Set ADCPRE bits according to RCC_PCLK value */
    802            RCC->CFGR |= RCC_ADCCLK & 0xFFFF;
   \   0000002A   0x....             LDR      R0,??DataTable21  ;; 0x40021004
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xB2A1             UXTH     R1,R4
   \   00000030   0x4301             ORRS     R1,R1,R0
   \   00000032   0x....             LDR      R0,??DataTable21  ;; 0x40021004
   \   00000034   0x6001             STR      R1,[R0, #+0]
    803          
    804            /* Clear ADCSW bit */
    805            RCC->CFGR3 &= ~RCC_CFGR3_ADCSW; 
   \   00000036   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x....             LDR      R1,??DataTable25  ;; 0xfffffeff
   \   0000003C   0x4001             ANDS     R1,R1,R0
   \   0000003E   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   00000040   0x6001             STR      R1,[R0, #+0]
    806            /* Set ADCSW bits according to RCC_ADCCLK value */
    807            RCC->CFGR3 |= RCC_ADCCLK >> 16;  
   \   00000042   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x0C21             LSRS     R1,R4,#+16
   \   00000048   0x4301             ORRS     R1,R1,R0
   \   0000004A   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   0000004C   0x6001             STR      R1,[R0, #+0]
    808          }
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    809          
    810          /**
    811            * @brief  Configures the CEC clock (CECCLK).
    812            * @param  RCC_CECCLK: defines the CEC clock source. This clock is derived 
    813            *         from the HSI or LSE clock.
    814            *         This parameter can be one of the following values:
    815            *             @arg RCC_CECCLK_HSI_Div244: CEC clock = HSI/244 (32768Hz)
    816            *             @arg RCC_CECCLK_LSE: CEC clock = LSE
    817            * @retval None
    818            */

   \                                 In section .text, align 2, keep-with-next
    819          void RCC_CECCLKConfig(uint32_t RCC_CECCLK)
    820          { 
   \                     RCC_CECCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    821            /* Check the parameters */
    822            assert_param(IS_RCC_CECCLK(RCC_CECCLK));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD005             BEQ      ??RCC_CECCLKConfig_0
   \   00000008   0x2C40             CMP      R4,#+64
   \   0000000A   0xD003             BEQ      ??RCC_CECCLKConfig_0
   \   0000000C   0x....             LDR      R1,??DataTable25_1  ;; 0x336
   \   0000000E   0x....             LDR      R0,??DataTable23_1
   \   00000010   0x.... 0x....      BL       assert_failed
    823          
    824            /* Clear CECSW bit */
    825            RCC->CFGR3 &= ~RCC_CFGR3_CECSW;
   \                     ??RCC_CECCLKConfig_0: (+1)
   \   00000014   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x2140             MOVS     R1,#+64
   \   0000001A   0x4388             BICS     R0,R0,R1
   \   0000001C   0x....             LDR      R1,??DataTable26  ;; 0x40021030
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    826            /* Set CECSW bits according to RCC_CECCLK value */
    827            RCC->CFGR3 |= RCC_CECCLK;
   \   00000020   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x4304             ORRS     R4,R4,R0
   \   00000026   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   00000028   0x6004             STR      R4,[R0, #+0]
    828          }
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    829          
    830          /**
    831            * @brief  Configures the I2C1 clock (I2C1CLK).
    832            * @param  RCC_I2CCLK: defines the I2C1 clock source. This clock is derived 
    833            *         from the HSI or System clock.
    834            *         This parameter can be one of the following values:
    835            *             @arg RCC_I2C1CLK_HSI: I2C1 clock = HSI
    836            *             @arg RCC_I2C1CLK_SYSCLK: I2C1 clock = System Clock
    837            * @retval None
    838            */

   \                                 In section .text, align 2, keep-with-next
    839          void RCC_I2CCLKConfig(uint32_t RCC_I2CCLK)
    840          { 
   \                     RCC_I2CCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    841            /* Check the parameters */
    842            assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD005             BEQ      ??RCC_I2CCLKConfig_0
   \   00000008   0x2C10             CMP      R4,#+16
   \   0000000A   0xD003             BEQ      ??RCC_I2CCLKConfig_0
   \   0000000C   0x....             LDR      R1,??DataTable26_1  ;; 0x34a
   \   0000000E   0x....             LDR      R0,??DataTable23_1
   \   00000010   0x.... 0x....      BL       assert_failed
    843          
    844            /* Clear I2CSW bit */
    845            RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
   \                     ??RCC_I2CCLKConfig_0: (+1)
   \   00000014   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x2110             MOVS     R1,#+16
   \   0000001A   0x4388             BICS     R0,R0,R1
   \   0000001C   0x....             LDR      R1,??DataTable26  ;; 0x40021030
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    846            /* Set I2CSW bits according to RCC_I2CCLK value */
    847            RCC->CFGR3 |= RCC_I2CCLK;
   \   00000020   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x4304             ORRS     R4,R4,R0
   \   00000026   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   00000028   0x6004             STR      R4,[R0, #+0]
    848          }
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    849          
    850          /**
    851            * @brief  Configures the USART1 clock (USART1CLK).
    852            * @param  RCC_USARTCLK: defines the USART1 clock source. This clock is derived 
    853            *         from the HSI or System clock.
    854            *         This parameter can be one of the following values:
    855            *             @arg RCC_USART1CLK_PCLK: USART1 clock = APB Clock (PCLK)
    856            *             @arg RCC_USART1CLK_SYSCLK: USART1 clock = System Clock
    857            *             @arg RCC_USART1CLK_LSE: USART1 clock = LSE Clock
    858            *             @arg RCC_USART1CLK_HSI: USART1 clock = HSI Clock
    859            * @retval None
    860            */

   \                                 In section .text, align 2, keep-with-next
    861          void RCC_USARTCLKConfig(uint32_t RCC_USARTCLK)
    862          { 
   \                     RCC_USARTCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    863            /* Check the parameters */
    864            assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD00A             BEQ      ??RCC_USARTCLKConfig_0
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD008             BEQ      ??RCC_USARTCLKConfig_0
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xD006             BEQ      ??RCC_USARTCLKConfig_0
   \   00000010   0x2C03             CMP      R4,#+3
   \   00000012   0xD004             BEQ      ??RCC_USARTCLKConfig_0
   \   00000014   0x21D8             MOVS     R1,#+216
   \   00000016   0x0089             LSLS     R1,R1,#+2        ;; #+864
   \   00000018   0x....             LDR      R0,??DataTable23_1
   \   0000001A   0x.... 0x....      BL       assert_failed
    865          
    866            /* Clear USARTSW[1:0] bit */
    867            RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
   \                     ??RCC_USARTCLKConfig_0: (+1)
   \   0000001E   0x....             LDR      R0,??DataTable28  ;; 0x40021030
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2103             MOVS     R1,#+3
   \   00000024   0x4388             BICS     R0,R0,R1
   \   00000026   0x....             LDR      R1,??DataTable28  ;; 0x40021030
   \   00000028   0x6008             STR      R0,[R1, #+0]
    868            /* Set USARTSW bits according to RCC_USARTCLK value */
    869            RCC->CFGR3 |= RCC_USARTCLK;
   \   0000002A   0x....             LDR      R0,??DataTable28  ;; 0x40021030
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x4304             ORRS     R4,R4,R0
   \   00000030   0x....             LDR      R0,??DataTable28  ;; 0x40021030
   \   00000032   0x6004             STR      R4,[R0, #+0]
    870          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    871          
    872          /**
    873            * @brief  Returns the frequencies of the System, AHB and APB busses clocks.
    874            * @note    The frequency returned by this function is not the real frequency
    875            *           in the chip. It is calculated based on the predefined constant and
    876            *           the source selected by RCC_SYSCLKConfig():
    877            *                                              
    878            * @note     If SYSCLK source is HSI, function returns constant HSI_VALUE(*)
    879            *                                              
    880            * @note     If SYSCLK source is HSE, function returns constant HSE_VALUE(**)
    881            *                          
    882            * @note     If SYSCLK source is PLL, function returns constant HSE_VALUE(**) 
    883            *             or HSI_VALUE(*) multiplied by the PLL factors.
    884            *         
    885            *         (*) HSI_VALUE is a constant defined in stm32f0xx.h file (default value
    886            *             8 MHz) but the real value may vary depending on the variations
    887            *             in voltage and temperature, refer to RCC_AdjustHSICalibrationValue().   
    888            *    
    889            *         (**) HSE_VALUE is a constant defined in stm32f0xx.h file (default value
    890            *              8 MHz), user has to ensure that HSE_VALUE is same as the real
    891            *              frequency of the crystal used. Otherwise, this function may
    892            *              return wrong result.
    893            *                
    894            *         - The result of this function could be not correct when using fractional
    895            *           value for HSE crystal.   
    896            *             
    897            * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold 
    898            *         the clocks frequencies. 
    899            *     
    900            * @note     This function can be used by the user application to compute the 
    901            *           baudrate for the communication peripherals or configure other parameters.
    902            * @note     Each time SYSCLK, HCLK and/or PCLK clock changes, this function
    903            *           must be called to update the structure's field. Otherwise, any
    904            *           configuration based on this function will be incorrect.
    905            *    
    906            * @retval None
    907            */

   \                                 In section .text, align 2, keep-with-next
    908          void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
    909          {
   \                     RCC_GetClocksFreq: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    910            uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x2000             MOVS     R0,#+0
    911          
    912            /* Get SYSCLK source -------------------------------------------------------*/
    913            tmp = RCC->CFGR & RCC_CFGR_SWS;
   \   0000000E   0x....             LDR      R0,??DataTable24  ;; 0x40021004
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x200C             MOVS     R0,#+12
   \   00000014   0x4008             ANDS     R0,R0,R1
    914            
    915            switch (tmp)
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ      ??RCC_GetClocksFreq_0
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xD005             BEQ      ??RCC_GetClocksFreq_1
   \   0000001E   0x2808             CMP      R0,#+8
   \   00000020   0xD006             BEQ      ??RCC_GetClocksFreq_2
   \   00000022   0xE022             B        ??RCC_GetClocksFreq_3
    916            {
    917              case 0x00:  /* HSI used as system clock */
    918                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_0: (+1)
   \   00000024   0x....             LDR      R0,??DataTable29  ;; 0x7a1200
   \   00000026   0x6020             STR      R0,[R4, #+0]
    919                break;
   \   00000028   0xE021             B        ??RCC_GetClocksFreq_4
    920              case 0x04:  /* HSE used as system clock */
    921                RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
   \                     ??RCC_GetClocksFreq_1: (+1)
   \   0000002A   0x....             LDR      R0,??DataTable27  ;; 0x5b8d80
   \   0000002C   0x6020             STR      R0,[R4, #+0]
    922                break;
   \   0000002E   0xE01E             B        ??RCC_GetClocksFreq_4
    923              case 0x08:  /* PLL used as system clock */
    924                /* Get PLL clock source and multiplication factor ----------------------*/
    925                pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
   \                     ??RCC_GetClocksFreq_2: (+1)
   \   00000030   0x....             LDR      R0,??DataTable24  ;; 0x40021004
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0x20F0             MOVS     R0,#+240
   \   00000036   0x0380             LSLS     R0,R0,#+14       ;; #+3932160
   \   00000038   0x4008             ANDS     R0,R0,R1
    926                pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
   \   0000003A   0x....             LDR      R1,??DataTable24  ;; 0x40021004
   \   0000003C   0x6809             LDR      R1,[R1, #+0]
   \   0000003E   0x2280             MOVS     R2,#+128
   \   00000040   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \   00000042   0x4011             ANDS     R1,R1,R2
    927                pllmull = ( pllmull >> 18) + 2;
   \   00000044   0x0C85             LSRS     R5,R0,#+18
   \   00000046   0x1CAD             ADDS     R5,R5,#+2
    928                
    929                if (pllsource == 0x00)
   \   00000048   0x2900             CMP      R1,#+0
   \   0000004A   0xD103             BNE      ??RCC_GetClocksFreq_5
    930                {
    931                  /* HSI oscillator clock divided by 2 selected as PLL clock entry */
    932                  RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
   \   0000004C   0x....             LDR      R0,??DataTable27_1  ;; 0x3d0900
   \   0000004E   0x4345             MULS     R5,R0,R5
   \   00000050   0x6025             STR      R5,[R4, #+0]
   \   00000052   0xE009             B        ??RCC_GetClocksFreq_6
    933                }
    934                else
    935                {
    936                  prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
   \                     ??RCC_GetClocksFreq_5: (+1)
   \   00000054   0x....             LDR      R0,??DataTable28_1  ;; 0x4002102c
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x0701             LSLS     R1,R0,#+28       ;; ZeroExtS R1,R0,#+28,#+28
   \   0000005A   0x0F09             LSRS     R1,R1,#+28
   \   0000005C   0x1C49             ADDS     R1,R1,#+1
    937                  /* HSE oscillator clock selected as PREDIV1 clock entry */
    938                  RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
   \   0000005E   0x....             LDR      R0,??DataTable27  ;; 0x5b8d80
   \   00000060   0x.... 0x....      BL       __aeabi_uidiv
   \   00000064   0x4368             MULS     R0,R5,R0
   \   00000066   0x6020             STR      R0,[R4, #+0]
    939                }      
    940                break;
   \                     ??RCC_GetClocksFreq_6: (+1)
   \   00000068   0xE001             B        ??RCC_GetClocksFreq_4
    941              default: /* HSI used as system clock */
    942                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_3: (+1)
   \   0000006A   0x....             LDR      R0,??DataTable29  ;; 0x7a1200
   \   0000006C   0x6020             STR      R0,[R4, #+0]
    943                break;
    944            }
    945            /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
    946            /* Get HCLK prescaler */
    947            tmp = RCC->CFGR & RCC_CFGR_HPRE;
   \                     ??RCC_GetClocksFreq_4: (+1)
   \   0000006E   0x....             LDR      R0,??DataTable24  ;; 0x40021004
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x20F0             MOVS     R0,#+240
   \   00000074   0x4008             ANDS     R0,R0,R1
    948            tmp = tmp >> 4;
   \   00000076   0x0900             LSRS     R0,R0,#+4
    949            presc = APBAHBPrescTable[tmp]; 
   \   00000078   0x....             LDR      R1,??DataTable28_2
   \   0000007A   0x5C08             LDRB     R0,[R1, R0]
    950            /* HCLK clock frequency */
    951            RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x40C1             LSRS     R1,R1,R0
   \   00000080   0x6061             STR      R1,[R4, #+4]
    952          
    953            /* Get PCLK prescaler */
    954            tmp = RCC->CFGR & RCC_CFGR_PPRE;
   \   00000082   0x....             LDR      R0,??DataTable24  ;; 0x40021004
   \   00000084   0x6801             LDR      R1,[R0, #+0]
   \   00000086   0x20E0             MOVS     R0,#+224
   \   00000088   0x00C0             LSLS     R0,R0,#+3        ;; #+1792
   \   0000008A   0x4008             ANDS     R0,R0,R1
    955            tmp = tmp >> 8;
   \   0000008C   0x0A00             LSRS     R0,R0,#+8
    956            presc = APBAHBPrescTable[tmp];
   \   0000008E   0x....             LDR      R1,??DataTable28_2
   \   00000090   0x5C08             LDRB     R0,[R1, R0]
    957            /* PCLK clock frequency */
    958            RCC_Clocks->PCLK_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   00000092   0x6861             LDR      R1,[R4, #+4]
   \   00000094   0x40C1             LSRS     R1,R1,R0
   \   00000096   0x60A1             STR      R1,[R4, #+8]
    959          
    960            /* ADCCLK clock frequency */
    961            if((RCC->CFGR3 & RCC_CFGR3_ADCSW) != RCC_CFGR3_ADCSW)
   \   00000098   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x05C0             LSLS     R0,R0,#+23
   \   0000009E   0xD402             BMI      ??RCC_GetClocksFreq_7
    962            {
    963              /* ADC Clock is HSI14 Osc. */
    964              RCC_Clocks->ADCCLK_Frequency = HSI14_VALUE;
   \   000000A0   0x....             LDR      R0,??DataTable28_3  ;; 0xd59f80
   \   000000A2   0x60E0             STR      R0,[R4, #+12]
   \   000000A4   0xE00A             B        ??RCC_GetClocksFreq_8
    965            }
    966            else
    967            {
    968              if((RCC->CFGR & RCC_CFGR_ADCPRE) != RCC_CFGR_ADCPRE)
   \                     ??RCC_GetClocksFreq_7: (+1)
   \   000000A6   0x....             LDR      R0,??DataTable24  ;; 0x40021004
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x0440             LSLS     R0,R0,#+17
   \   000000AC   0xD403             BMI      ??RCC_GetClocksFreq_9
    969              {
    970                /* ADC Clock is derived from PCLK/2 */
    971                RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 1;
   \   000000AE   0x68A0             LDR      R0,[R4, #+8]
   \   000000B0   0x0840             LSRS     R0,R0,#+1
   \   000000B2   0x60E0             STR      R0,[R4, #+12]
   \   000000B4   0xE002             B        ??RCC_GetClocksFreq_8
    972              }
    973              else
    974              {
    975                /* ADC Clock is derived from PCLK/4 */
    976                RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 2;
   \                     ??RCC_GetClocksFreq_9: (+1)
   \   000000B6   0x68A0             LDR      R0,[R4, #+8]
   \   000000B8   0x0880             LSRS     R0,R0,#+2
   \   000000BA   0x60E0             STR      R0,[R4, #+12]
    977              }
    978              
    979            }
    980          
    981            /* CECCLK clock frequency */
    982            if((RCC->CFGR3 & RCC_CFGR3_CECSW) != RCC_CFGR3_CECSW)
   \                     ??RCC_GetClocksFreq_8: (+1)
   \   000000BC   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0x0640             LSLS     R0,R0,#+25
   \   000000C2   0xD402             BMI      ??RCC_GetClocksFreq_10
    983            {
    984              /* CEC Clock is HSI/256 */
    985              RCC_Clocks->CECCLK_Frequency = HSI_VALUE / 244;
   \   000000C4   0x....             LDR      R0,??DataTable29_1  ;; 0x8012
   \   000000C6   0x6120             STR      R0,[R4, #+16]
   \   000000C8   0xE002             B        ??RCC_GetClocksFreq_11
    986            }
    987            else
    988            {
    989              /* CECC Clock is LSE Osc. */
    990              RCC_Clocks->CECCLK_Frequency = LSE_VALUE;
   \                     ??RCC_GetClocksFreq_10: (+1)
   \   000000CA   0x2080             MOVS     R0,#+128
   \   000000CC   0x0200             LSLS     R0,R0,#+8        ;; #+32768
   \   000000CE   0x6120             STR      R0,[R4, #+16]
    991            }
    992          
    993            /* I2C1CLK clock frequency */
    994            if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
   \                     ??RCC_GetClocksFreq_11: (+1)
   \   000000D0   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0x06C0             LSLS     R0,R0,#+27
   \   000000D6   0xD402             BMI      ??RCC_GetClocksFreq_12
    995            {
    996              /* I2C1 Clock is HSI Osc. */
    997              RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
   \   000000D8   0x....             LDR      R0,??DataTable29  ;; 0x7a1200
   \   000000DA   0x6160             STR      R0,[R4, #+20]
   \   000000DC   0xE001             B        ??RCC_GetClocksFreq_13
    998            }
    999            else
   1000            {
   1001              /* I2C1 Clock is System Clock */
   1002              RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
   \                     ??RCC_GetClocksFreq_12: (+1)
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x6160             STR      R0,[R4, #+20]
   1003            }
   1004          
   1005            /* USART1CLK clock frequency */
   1006            if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
   \                     ??RCC_GetClocksFreq_13: (+1)
   \   000000E2   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000000E8   0x0F80             LSRS     R0,R0,#+30
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD102             BNE      ??RCC_GetClocksFreq_14
   1007            {
   1008              /* USART1 Clock is PCLK */
   1009              RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK_Frequency;
   \   000000EE   0x68A0             LDR      R0,[R4, #+8]
   \   000000F0   0x61A0             STR      R0,[R4, #+24]
   \   000000F2   0xE01A             B        ??RCC_GetClocksFreq_15
   1010            }
   1011            else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
   \                     ??RCC_GetClocksFreq_14: (+1)
   \   000000F4   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000000FA   0x0F80             LSRS     R0,R0,#+30
   \   000000FC   0x2801             CMP      R0,#+1
   \   000000FE   0xD102             BNE      ??RCC_GetClocksFreq_16
   1012            {
   1013              /* USART1 Clock is System Clock */
   1014              RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
   \   00000100   0x6820             LDR      R0,[R4, #+0]
   \   00000102   0x61A0             STR      R0,[R4, #+24]
   \   00000104   0xE011             B        ??RCC_GetClocksFreq_15
   1015            }
   1016            else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
   \                     ??RCC_GetClocksFreq_16: (+1)
   \   00000106   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000010C   0x0F80             LSRS     R0,R0,#+30
   \   0000010E   0x2802             CMP      R0,#+2
   \   00000110   0xD103             BNE      ??RCC_GetClocksFreq_17
   1017            {
   1018              /* USART1 Clock is LSE Osc. */
   1019              RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
   \   00000112   0x2080             MOVS     R0,#+128
   \   00000114   0x0200             LSLS     R0,R0,#+8        ;; #+32768
   \   00000116   0x61A0             STR      R0,[R4, #+24]
   \   00000118   0xE007             B        ??RCC_GetClocksFreq_15
   1020            }
   1021            else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
   \                     ??RCC_GetClocksFreq_17: (+1)
   \   0000011A   0x....             LDR      R0,??DataTable26  ;; 0x40021030
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000120   0x0F80             LSRS     R0,R0,#+30
   \   00000122   0x2803             CMP      R0,#+3
   \   00000124   0xD101             BNE      ??RCC_GetClocksFreq_15
   1022            {
   1023              /* USART1 Clock is HSI Osc. */
   1024              RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
   \   00000126   0x....             LDR      R0,??DataTable29  ;; 0x7a1200
   \   00000128   0x61A0             STR      R0,[R4, #+24]
   1025            }
   1026          
   1027          }
   \                     ??RCC_GetClocksFreq_15: (+1)
   \   0000012A   0xBD30             POP      {R4,R5,PC}       ;; return
   1028          
   1029          
   1030          /**
   1031            * @}
   1032            */
   1033          
   1034          /** @defgroup RCC_Group3 Peripheral clocks configuration functions
   1035           *  @brief   Peripheral clocks configuration functions 
   1036           *
   1037          @verbatim
   1038           ===============================================================================
   1039                       #####Peripheral clocks configuration functions #####
   1040           ===============================================================================  
   1041          
   1042              [..] This section provide functions allowing to configure the Peripheral clocks. 
   1043                   (#) The RTC clock which is derived from the LSE, LSI or  HSE_Div32 (HSE
   1044                       divided by 32).
   1045                   (#) After restart from Reset or wakeup from STANDBY, all peripherals are off
   1046                       except internal SRAM, Flash and SWD. Before to start using a peripheral you
   1047                       have to enable its interface clock. You can do this using RCC_AHBPeriphClockCmd(),
   1048                       RCC_APB2PeriphClockCmd() and RCC_APB1PeriphClockCmd() functions.
   1049                   (#) To reset the peripherals configuration (to the default state after device reset)
   1050                       you can use RCC_AHBPeriphResetCmd(), RCC_APB2PeriphResetCmd() and 
   1051                       RCC_APB1PeriphResetCmd() functions.
   1052          
   1053          @endverbatim
   1054            * @{
   1055            */
   1056          
   1057          /**
   1058            * @brief  Configures the RTC clock (RTCCLK).
   1059            * @note     As the RTC clock configuration bits are in the Backup domain and write
   1060            *           access is denied to this domain after reset, you have to enable write
   1061            *           access using PWR_BackupAccessCmd(ENABLE) function before to configure
   1062            *           the RTC clock source (to be done once after reset).    
   1063            * @note     Once the RTC clock is configured it can't be changed unless the RTC
   1064            *           is reset using RCC_BackupResetCmd function, or by a Power On Reset (POR)
   1065            *             
   1066            * @param  RCC_RTCCLKSource: specifies the RTC clock source.
   1067            *   This parameter can be one of the following values:
   1068            *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
   1069            *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
   1070            *     @arg RCC_RTCCLKSource_HSE_Div32: HSE divided by 32 selected as RTC clock
   1071            *       
   1072            * @note     If the LSE or LSI is used as RTC clock source, the RTC continues to
   1073            *           work in STOP and STANDBY modes, and can be used as wakeup source.
   1074            *           However, when the HSE clock is used as RTC clock source, the RTC
   1075            *           cannot be used in STOP and STANDBY modes.
   1076            *             
   1077            * @note     The maximum input clock frequency for RTC is 2MHz (when using HSE as
   1078            *           RTC clock source).
   1079            *                          
   1080            * @retval None
   1081            */

   \                                 In section .text, align 2, keep-with-next
   1082          void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
   1083          {
   \                     RCC_RTCCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1084            /* Check the parameters */
   1085            assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
   \   00000004   0x2080             MOVS     R0,#+128
   \   00000006   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ      ??RCC_RTCCLKConfig_0
   \   0000000C   0x2080             MOVS     R0,#+128
   \   0000000E   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD007             BEQ      ??RCC_RTCCLKConfig_0
   \   00000014   0x20C0             MOVS     R0,#+192
   \   00000016   0x0080             LSLS     R0,R0,#+2        ;; #+768
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD003             BEQ      ??RCC_RTCCLKConfig_0
   \   0000001C   0x....             LDR      R1,??DataTable30  ;; 0x43d
   \   0000001E   0x....             LDR      R0,??DataTable30_1
   \   00000020   0x.... 0x....      BL       assert_failed
   1086            
   1087            /* Select the RTC clock source */
   1088            RCC->BDCR |= RCC_RTCCLKSource;
   \                     ??RCC_RTCCLKConfig_0: (+1)
   \   00000024   0x....             LDR      R0,??DataTable32  ;; 0x40021020
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4304             ORRS     R4,R4,R0
   \   0000002A   0x....             LDR      R0,??DataTable32  ;; 0x40021020
   \   0000002C   0x6004             STR      R4,[R0, #+0]
   1089          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1090          
   1091          /**
   1092            * @brief  Enables or disables the RTC clock.
   1093            * @note   This function must be used only after the RTC clock source was selected
   1094            *         using the RCC_RTCCLKConfig function.
   1095            * @param  NewState: new state of the RTC clock.
   1096            *         This parameter can be: ENABLE or DISABLE.
   1097            * @retval None
   1098            */

   \                                 In section .text, align 2, keep-with-next
   1099          void RCC_RTCCLKCmd(FunctionalState NewState)
   1100          {
   \                     RCC_RTCCLKCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1101            /* Check the parameters */
   1102            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD007             BEQ      ??RCC_RTCCLKCmd_0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD003             BEQ      ??RCC_RTCCLKCmd_0
   \   00000014   0x....             LDR      R1,??DataTable31  ;; 0x44e
   \   00000016   0x....             LDR      R0,??DataTable30_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1103            
   1104            if (NewState != DISABLE)
   \                     ??RCC_RTCCLKCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD007             BEQ      ??RCC_RTCCLKCmd_1
   1105            {
   1106              RCC->BDCR |= RCC_BDCR_RTCEN;
   \   00000022   0x....             LDR      R0,??DataTable32  ;; 0x40021020
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \   0000002A   0x4301             ORRS     R1,R1,R0
   \   0000002C   0x....             LDR      R0,??DataTable32  ;; 0x40021020
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   \   00000030   0xE005             B        ??RCC_RTCCLKCmd_2
   1107            }
   1108            else
   1109            {
   1110              RCC->BDCR &= ~RCC_BDCR_RTCEN;
   \                     ??RCC_RTCCLKCmd_1: (+1)
   \   00000032   0x....             LDR      R0,??DataTable32  ;; 0x40021020
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x....             LDR      R1,??DataTable31_1  ;; 0xffff7fff
   \   00000038   0x4001             ANDS     R1,R1,R0
   \   0000003A   0x....             LDR      R0,??DataTable32  ;; 0x40021020
   \   0000003C   0x6001             STR      R1,[R0, #+0]
   1111            }
   1112          }
   \                     ??RCC_RTCCLKCmd_2: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
   1113          
   1114          /**
   1115            * @brief  Forces or releases the Backup domain reset.
   1116            * @note   This function resets the RTC peripheral (including the backup registers)
   1117            *         and the RTC clock source selection in RCC_BDCR register.
   1118            * @param  NewState: new state of the Backup domain reset.
   1119            *         This parameter can be: ENABLE or DISABLE.
   1120            * @retval None
   1121            */

   \                                 In section .text, align 2, keep-with-next
   1122          void RCC_BackupResetCmd(FunctionalState NewState)
   1123          {
   \                     RCC_BackupResetCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1124            /* Check the parameters */
   1125            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD007             BEQ      ??RCC_BackupResetCmd_0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD003             BEQ      ??RCC_BackupResetCmd_0
   \   00000014   0x....             LDR      R1,??DataTable31_2  ;; 0x465
   \   00000016   0x....             LDR      R0,??DataTable30_1
   \   00000018   0x.... 0x....      BL       assert_failed
   1126            
   1127            if (NewState != DISABLE)
   \                     ??RCC_BackupResetCmd_0: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD007             BEQ      ??RCC_BackupResetCmd_1
   1128            {
   1129              RCC->BDCR |= RCC_BDCR_BDRST;
   \   00000022   0x....             LDR      R0,??DataTable32  ;; 0x40021020
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   0000002A   0x4301             ORRS     R1,R1,R0
   \   0000002C   0x....             LDR      R0,??DataTable32  ;; 0x40021020
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   \   00000030   0xE005             B        ??RCC_BackupResetCmd_2
   1130            }
   1131            else
   1132            {
   1133              RCC->BDCR &= ~RCC_BDCR_BDRST;
   \                     ??RCC_BackupResetCmd_1: (+1)
   \   00000032   0x....             LDR      R0,??DataTable32  ;; 0x40021020
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x....             LDR      R1,??DataTable32_1  ;; 0xfffeffff
   \   00000038   0x4001             ANDS     R1,R1,R0
   \   0000003A   0x....             LDR      R0,??DataTable32  ;; 0x40021020
   \   0000003C   0x6001             STR      R1,[R0, #+0]
   1134            }
   1135          }
   \                     ??RCC_BackupResetCmd_2: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
   1136          
   1137          /**
   1138            * @brief  Enables or disables the AHB peripheral clock.
   1139            * @note   After reset, the peripheral clock (used for registers read/write access)
   1140            *         is disabled and the application software has to enable this clock before 
   1141            *         using it.    
   1142            * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
   1143            *         This parameter can be any combination of the following values:
   1144            *             @arg RCC_AHBPeriph_GPIOA:         GPIOA clock
   1145            *             @arg RCC_AHBPeriph_GPIOB:         GPIOB clock
   1146            *             @arg RCC_AHBPeriph_GPIOC:         GPIOC clock
   1147            *             @arg RCC_AHBPeriph_GPIOD:         GPIOD clock
   1148            *             @arg RCC_AHBPeriph_GPIOF:         GPIOF clock
   1149            *             @arg RCC_AHBPeriph_TS:            TS clock
   1150            *             @arg RCC_AHBPeriph_CRC:           CRC clock
   1151            *             @arg RCC_AHBPeriph_FLITF: (has effect only when the Flash memory is in power down mode)  
   1152            *             @arg RCC_AHBPeriph_SRAM:          SRAM clock
   1153            *             @arg RCC_AHBPeriph_DMA1:          DMA1 clock
   1154            * @param  NewState: new state of the specified peripheral clock.
   1155            *         This parameter can be: ENABLE or DISABLE.
   1156            * @retval None
   1157            */

   \                                 In section .text, align 2, keep-with-next
   1158          void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
   1159          {
   \                     RCC_AHBPeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1160            /* Check the parameters */
   1161            assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
   \   00000006   0x....             LDR      R0,??DataTable32_2  ;; 0xfea1ffaa
   \   00000008   0x4020             ANDS     R0,R0,R4
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE      ??RCC_AHBPeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD103             BNE      ??RCC_AHBPeriphClockCmd_1
   \                     ??RCC_AHBPeriphClockCmd_0: (+1)
   \   00000012   0x....             LDR      R1,??DataTable32_3  ;; 0x489
   \   00000014   0x....             LDR      R0,??DataTable30_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1162            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHBPeriphClockCmd_1: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD007             BEQ      ??RCC_AHBPeriphClockCmd_2
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD003             BEQ      ??RCC_AHBPeriphClockCmd_2
   \   0000002A   0x....             LDR      R1,??DataTable32_4  ;; 0x48a
   \   0000002C   0x....             LDR      R0,??DataTable30_1
   \   0000002E   0x.... 0x....      BL       assert_failed
   1163            
   1164            if (NewState != DISABLE)
   \                     ??RCC_AHBPeriphClockCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ      ??RCC_AHBPeriphClockCmd_3
   1165            {
   1166              RCC->AHBENR |= RCC_AHBPeriph;
   \   00000038   0x....             LDR      R0,??DataTable33  ;; 0x40021014
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4304             ORRS     R4,R4,R0
   \   0000003E   0x....             LDR      R0,??DataTable33  ;; 0x40021014
   \   00000040   0x6004             STR      R4,[R0, #+0]
   \   00000042   0xE004             B        ??RCC_AHBPeriphClockCmd_4
   1167            }
   1168            else
   1169            {
   1170              RCC->AHBENR &= ~RCC_AHBPeriph;
   \                     ??RCC_AHBPeriphClockCmd_3: (+1)
   \   00000044   0x....             LDR      R0,??DataTable33  ;; 0x40021014
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x43A0             BICS     R0,R0,R4
   \   0000004A   0x....             LDR      R1,??DataTable33  ;; 0x40021014
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1171            }
   1172          }
   \                     ??RCC_AHBPeriphClockCmd_4: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1173          
   1174          /**
   1175            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
   1176            * @note   After reset, the peripheral clock (used for registers read/write access)
   1177            *         is disabled and the application software has to enable this clock before 
   1178            *         using it.
   1179            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1180            *         This parameter can be any combination of the following values:
   1181            *             @arg RCC_APB2Periph_SYSCFG:      SYSCFG clock
   1182            *             @arg RCC_APB2Periph_ADC1:        ADC1 clock
   1183            *             @arg RCC_APB2Periph_TIM1:        TIM1 clock
   1184            *             @arg RCC_APB2Periph_SPI1:        SPI1 clock
   1185            *             @arg RCC_APB2Periph_USART1:      USART1 clock
   1186            *             @arg RCC_APB2Periph_TIM15:       TIM15 clock
   1187            *             @arg RCC_APB2Periph_TIM16:       TIM16 clock
   1188            *             @arg RCC_APB2Periph_TIM17:       TIM17 clock
   1189            *             @arg RCC_APB2Periph_DBGMCU:      DBGMCU clock
   1190            * @param  NewState: new state of the specified peripheral clock.
   1191            *         This parameter can be: ENABLE or DISABLE.
   1192            * @retval None
   1193            */

   \                                 In section .text, align 2, keep-with-next
   1194          void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1195          {
   \                     RCC_APB2PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1196            /* Check the parameters */
   1197            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   \   00000006   0x....             LDR      R0,??DataTable33_1  ;; 0xffb8a5fe
   \   00000008   0x4020             ANDS     R0,R0,R4
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE      ??RCC_APB2PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD103             BNE      ??RCC_APB2PeriphClockCmd_1
   \                     ??RCC_APB2PeriphClockCmd_0: (+1)
   \   00000012   0x....             LDR      R1,??DataTable33_2  ;; 0x4ad
   \   00000014   0x....             LDR      R0,??DataTable30_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1198            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB2PeriphClockCmd_1: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD007             BEQ      ??RCC_APB2PeriphClockCmd_2
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD003             BEQ      ??RCC_APB2PeriphClockCmd_2
   \   0000002A   0x....             LDR      R1,??DataTable33_3  ;; 0x4ae
   \   0000002C   0x....             LDR      R0,??DataTable30_1
   \   0000002E   0x.... 0x....      BL       assert_failed
   1199          
   1200            if (NewState != DISABLE)
   \                     ??RCC_APB2PeriphClockCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ      ??RCC_APB2PeriphClockCmd_3
   1201            {
   1202              RCC->APB2ENR |= RCC_APB2Periph;
   \   00000038   0x....             LDR      R0,??DataTable35  ;; 0x40021018
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4304             ORRS     R4,R4,R0
   \   0000003E   0x....             LDR      R0,??DataTable35  ;; 0x40021018
   \   00000040   0x6004             STR      R4,[R0, #+0]
   \   00000042   0xE004             B        ??RCC_APB2PeriphClockCmd_4
   1203            }
   1204            else
   1205            {
   1206              RCC->APB2ENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockCmd_3: (+1)
   \   00000044   0x....             LDR      R0,??DataTable35  ;; 0x40021018
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x43A0             BICS     R0,R0,R4
   \   0000004A   0x....             LDR      R1,??DataTable35  ;; 0x40021018
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1207            }
   1208          }
   \                     ??RCC_APB2PeriphClockCmd_4: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1209          
   1210          /**
   1211            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
   1212            * @note   After reset, the peripheral clock (used for registers read/write access)
   1213            *         is disabled and the application software has to enable this clock before 
   1214            *         using it.
   1215            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1216            *         This parameter can be any combination of the following values:
   1217            *           @arg RCC_APB1Periph_TIM2:      TIM2 clock
   1218            *           @arg RCC_APB1Periph_TIM3:      TIM3 clock
   1219            *           @arg RCC_APB1Periph_TIM6:      TIM6 clock
   1220            *           @arg RCC_APB1Periph_TIM14:     TIM14 clock
   1221            *           @arg RCC_APB1Periph_WWDG:      WWDG clock
   1222            *           @arg RCC_APB1Periph_SPI2:      SPI2 clock
   1223            *           @arg RCC_APB1Periph_USART2:    USART2 clock
   1224            *           @arg RCC_APB1Periph_I2C1:      I2C1 clock
   1225            *           @arg RCC_APB1Periph_I2C2:      I2C2 clock
   1226            *           @arg RCC_APB1Periph_PWR:       PWR clock
   1227            *           @arg RCC_APB1Periph_DAC:       DAC clock
   1228            *           @arg RCC_APB1Periph_CEC:       CEC clock                               
   1229            * @param  NewState: new state of the specified peripheral clock.
   1230            *         This parameter can be: ENABLE or DISABLE.
   1231            * @retval None
   1232            */

   \                                 In section .text, align 2, keep-with-next
   1233          void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1234          {
   \                     RCC_APB1PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1235            /* Check the parameters */
   1236            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   \   00000006   0x....             LDR      R0,??DataTable33_4  ;; 0x8f9db6ec
   \   00000008   0x4020             ANDS     R0,R0,R4
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE      ??RCC_APB1PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD103             BNE      ??RCC_APB1PeriphClockCmd_1
   \                     ??RCC_APB1PeriphClockCmd_0: (+1)
   \   00000012   0x....             LDR      R1,??DataTable33_5  ;; 0x4d4
   \   00000014   0x....             LDR      R0,??DataTable30_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1237            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB1PeriphClockCmd_1: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD007             BEQ      ??RCC_APB1PeriphClockCmd_2
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD003             BEQ      ??RCC_APB1PeriphClockCmd_2
   \   0000002A   0x....             LDR      R1,??DataTable33_6  ;; 0x4d5
   \   0000002C   0x....             LDR      R0,??DataTable30_1
   \   0000002E   0x.... 0x....      BL       assert_failed
   1238          
   1239            if (NewState != DISABLE)
   \                     ??RCC_APB1PeriphClockCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ      ??RCC_APB1PeriphClockCmd_3
   1240            {
   1241              RCC->APB1ENR |= RCC_APB1Periph;
   \   00000038   0x....             LDR      R0,??DataTable35_1  ;; 0x4002101c
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4304             ORRS     R4,R4,R0
   \   0000003E   0x....             LDR      R0,??DataTable35_1  ;; 0x4002101c
   \   00000040   0x6004             STR      R4,[R0, #+0]
   \   00000042   0xE004             B        ??RCC_APB1PeriphClockCmd_4
   1242            }
   1243            else
   1244            {
   1245              RCC->APB1ENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockCmd_3: (+1)
   \   00000044   0x....             LDR      R0,??DataTable35_1  ;; 0x4002101c
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x43A0             BICS     R0,R0,R4
   \   0000004A   0x....             LDR      R1,??DataTable35_1  ;; 0x4002101c
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1246            }
   1247          }
   \                     ??RCC_APB1PeriphClockCmd_4: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1248          
   1249          /**
   1250            * @brief  Forces or releases AHB peripheral reset.
   1251            * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
   1252            *         This parameter can be any combination of the following values:
   1253            *             @arg RCC_AHBPeriph_GPIOA:         GPIOA clock
   1254            *             @arg RCC_AHBPeriph_GPIOB:         GPIOB clock
   1255            *             @arg RCC_AHBPeriph_GPIOC:         GPIOC clock
   1256            *             @arg RCC_AHBPeriph_GPIOD:         GPIOD clock
   1257            *             @arg RCC_AHBPeriph_GPIOF:         GPIOF clock
   1258            *             @arg RCC_AHBPeriph_TS:            TS clock
   1259            * @param  NewState: new state of the specified peripheral reset.
   1260            *         This parameter can be: ENABLE or DISABLE.
   1261            * @retval None
   1262            */

   \                                 In section .text, align 2, keep-with-next
   1263          void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
   1264          {
   \                     RCC_AHBPeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1265            /* Check the parameters */
   1266            assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
   \   00000006   0x....             LDR      R0,??DataTable35_2  ;; 0xfea1ffff
   \   00000008   0x4020             ANDS     R0,R0,R4
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE      ??RCC_AHBPeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD103             BNE      ??RCC_AHBPeriphResetCmd_1
   \                     ??RCC_AHBPeriphResetCmd_0: (+1)
   \   00000012   0x....             LDR      R1,??DataTable35_3  ;; 0x4f2
   \   00000014   0x....             LDR      R0,??DataTable30_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1267            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHBPeriphResetCmd_1: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD007             BEQ      ??RCC_AHBPeriphResetCmd_2
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD003             BEQ      ??RCC_AHBPeriphResetCmd_2
   \   0000002A   0x....             LDR      R1,??DataTable35_4  ;; 0x4f3
   \   0000002C   0x....             LDR      R0,??DataTable30_1
   \   0000002E   0x.... 0x....      BL       assert_failed
   1268          
   1269            if (NewState != DISABLE)
   \                     ??RCC_AHBPeriphResetCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ      ??RCC_AHBPeriphResetCmd_3
   1270            {
   1271              RCC->AHBRSTR |= RCC_AHBPeriph;
   \   00000038   0x....             LDR      R0,??DataTable37  ;; 0x40021028
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4304             ORRS     R4,R4,R0
   \   0000003E   0x....             LDR      R0,??DataTable37  ;; 0x40021028
   \   00000040   0x6004             STR      R4,[R0, #+0]
   \   00000042   0xE004             B        ??RCC_AHBPeriphResetCmd_4
   1272            }
   1273            else
   1274            {
   1275              RCC->AHBRSTR &= ~RCC_AHBPeriph;
   \                     ??RCC_AHBPeriphResetCmd_3: (+1)
   \   00000044   0x....             LDR      R0,??DataTable37  ;; 0x40021028
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x43A0             BICS     R0,R0,R4
   \   0000004A   0x....             LDR      R1,??DataTable37  ;; 0x40021028
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1276            }
   1277          }
   \                     ??RCC_AHBPeriphResetCmd_4: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1278          
   1279          /**
   1280            * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
   1281            * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
   1282            *         This parameter can be any combination of the following values:
   1283            *             @arg RCC_APB2Periph_SYSCFG:      SYSCFG clock
   1284            *             @arg RCC_APB2Periph_ADC1:        ADC1 clock
   1285            *             @arg RCC_APB2Periph_TIM1:        TIM1 clock
   1286            *             @arg RCC_APB2Periph_SPI1:        SPI1 clock
   1287            *             @arg RCC_APB2Periph_USART1:      USART1 clock
   1288            *             @arg RCC_APB2Periph_TIM15:       TIM15 clock
   1289            *             @arg RCC_APB2Periph_TIM16:       TIM16 clock
   1290            *             @arg RCC_APB2Periph_TIM17:       TIM17 clock
   1291            *             @arg RCC_APB2Periph_DBGMCU:      DBGMCU clock
   1292            * @param  NewState: new state of the specified peripheral reset.
   1293            *         This parameter can be: ENABLE or DISABLE.
   1294            * @retval None
   1295            */

   \                                 In section .text, align 2, keep-with-next
   1296          void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1297          {
   \                     RCC_APB2PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1298            /* Check the parameters */
   1299            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   \   00000006   0x....             LDR      R0,??DataTable33_1  ;; 0xffb8a5fe
   \   00000008   0x4020             ANDS     R0,R0,R4
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE      ??RCC_APB2PeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD103             BNE      ??RCC_APB2PeriphResetCmd_1
   \                     ??RCC_APB2PeriphResetCmd_0: (+1)
   \   00000012   0x....             LDR      R1,??DataTable36  ;; 0x513
   \   00000014   0x....             LDR      R0,??DataTable37_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1300            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB2PeriphResetCmd_1: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD007             BEQ      ??RCC_APB2PeriphResetCmd_2
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD003             BEQ      ??RCC_APB2PeriphResetCmd_2
   \   0000002A   0x....             LDR      R1,??DataTable37_2  ;; 0x514
   \   0000002C   0x....             LDR      R0,??DataTable37_1
   \   0000002E   0x.... 0x....      BL       assert_failed
   1301          
   1302            if (NewState != DISABLE)
   \                     ??RCC_APB2PeriphResetCmd_2: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD005             BEQ      ??RCC_APB2PeriphResetCmd_3
   1303            {
   1304              RCC->APB2RSTR |= RCC_APB2Periph;
   \   00000038   0x....             LDR      R0,??DataTable37_3  ;; 0x4002100c
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x4304             ORRS     R4,R4,R0
   \   0000003E   0x....             LDR      R0,??DataTable37_3  ;; 0x4002100c
   \   00000040   0x6004             STR      R4,[R0, #+0]
   \   00000042   0xE004             B        ??RCC_APB2PeriphResetCmd_4
   1305            }
   1306            else
   1307            {
   1308              RCC->APB2RSTR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphResetCmd_3: (+1)
   \   00000044   0x....             LDR      R0,??DataTable37_3  ;; 0x4002100c
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x43A0             BICS     R0,R0,R4
   \   0000004A   0x....             LDR      R1,??DataTable37_3  ;; 0x4002100c
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1309            }
   1310          }
   \                     ??RCC_APB2PeriphResetCmd_4: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1311          
   1312          /**
   1313            * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
   1314            * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
   1315            *         This parameter can be any combination of the following values:
   1316            *           @arg RCC_APB1Periph_TIM2:      TIM2 clock
   1317            *           @arg RCC_APB1Periph_TIM3:      TIM3 clock
   1318            *           @arg RCC_APB1Periph_TIM6:      TIM6 clock
   1319            *           @arg RCC_APB1Periph_TIM14:     TIM14 clock
   1320            *           @arg RCC_APB1Periph_WWDG:      WWDG clock
   1321            *           @arg RCC_APB1Periph_SPI2:      SPI2 clock
   1322            *           @arg RCC_APB1Periph_USART2:    USART2 clock
   1323            *           @arg RCC_APB1Periph_I2C1:      I2C1 clock
   1324            *           @arg RCC_APB1Periph_I2C2:      I2C2 clock
   1325            *           @arg RCC_APB1Periph_PWR:       PWR clock
   1326            *           @arg RCC_APB1Periph_DAC:       DAC clock
   1327            *           @arg RCC_APB1Periph_CEC:       CEC clock
   1328            * @param  NewState: new state of the specified peripheral clock.
   1329            *         This parameter can be: ENABLE or DISABLE.
   1330            * @retval None
   1331            */

   \                                 In section .text, align 2, keep-with-next
   1332          void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1333          {
   \                     RCC_APB1PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1334            /* Check the parameters */
   1335            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   \   00000006   0x....             LDR      R0,??DataTable33_4  ;; 0x8f9db6ec
   \   00000008   0x4020             ANDS     R0,R0,R4
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE      ??RCC_APB1PeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD103             BNE      ??RCC_APB1PeriphResetCmd_1
   \                     ??RCC_APB1PeriphResetCmd_0: (+1)
   \   00000012   0x....             LDR      R1,??DataTable37_4  ;; 0x537
   \   00000014   0x....             LDR      R0,??DataTable37_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1336            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB1PeriphResetCmd_1: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD008             BEQ      ??RCC_APB1PeriphResetCmd_2
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD004             BEQ      ??RCC_APB1PeriphResetCmd_2
   \   0000002A   0x21A7             MOVS     R1,#+167
   \   0000002C   0x00C9             LSLS     R1,R1,#+3        ;; #+1336
   \   0000002E   0x....             LDR      R0,??DataTable37_1
   \   00000030   0x.... 0x....      BL       assert_failed
   1337          
   1338            if (NewState != DISABLE)
   \                     ??RCC_APB1PeriphResetCmd_2: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD005             BEQ      ??RCC_APB1PeriphResetCmd_3
   1339            {
   1340              RCC->APB1RSTR |= RCC_APB1Periph;
   \   0000003A   0x....             LDR      R0,??DataTable37_5  ;; 0x40021010
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4304             ORRS     R4,R4,R0
   \   00000040   0x....             LDR      R0,??DataTable37_5  ;; 0x40021010
   \   00000042   0x6004             STR      R4,[R0, #+0]
   \   00000044   0xE004             B        ??RCC_APB1PeriphResetCmd_4
   1341            }
   1342            else
   1343            {
   1344              RCC->APB1RSTR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphResetCmd_3: (+1)
   \   00000046   0x....             LDR      R0,??DataTable37_5  ;; 0x40021010
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x43A0             BICS     R0,R0,R4
   \   0000004C   0x....             LDR      R1,??DataTable37_5  ;; 0x40021010
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1345            }
   1346          }
   \                     ??RCC_APB1PeriphResetCmd_4: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1347          
   1348          /**
   1349            * @}
   1350            */
   1351          
   1352          /** @defgroup RCC_Group4 Interrupts and flags management functions
   1353           *  @brief   Interrupts and flags management functions 
   1354           *
   1355          @verbatim
   1356           ===============================================================================
   1357                       ##### Interrupts and flags management functions #####
   1358           ===============================================================================
   1359          @endverbatim
   1360            * @{
   1361            */
   1362          
   1363          /**
   1364            * @brief  Enables or disables the specified RCC interrupts.
   1365            * @note   The CSS interrupt doesn't have an enable bit; once the CSS is enabled
   1366            *         and if the HSE clock fails, the CSS interrupt occurs and an NMI is
   1367            *         automatically generated. The NMI will be executed indefinitely, and 
   1368            *         since NMI has higher priority than any other IRQ (and main program)
   1369            *         the application will be stacked in the NMI ISR unless the CSS interrupt
   1370            *         pending bit is cleared.
   1371            * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
   1372            *         This parameter can be any combination of the following values:
   1373            *              @arg RCC_IT_LSIRDY: LSI ready interrupt
   1374            *              @arg RCC_IT_LSERDY: LSE ready interrupt
   1375            *              @arg RCC_IT_HSIRDY: HSI ready interrupt
   1376            *              @arg RCC_IT_HSERDY: HSE ready interrupt
   1377            *              @arg RCC_IT_PLLRDY: PLL ready interrupt
   1378            *              @arg RCC_IT_HSI14RDY: HSI14 ready interrupt
   1379            * @param  NewState: new state of the specified RCC interrupts.
   1380            *         This parameter can be: ENABLE or DISABLE.
   1381            * @retval None
   1382            */

   \                                 In section .text, align 2, keep-with-next
   1383          void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
   1384          {
   \                     RCC_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1385            /* Check the parameters */
   1386            assert_param(IS_RCC_IT(RCC_IT));
   \   00000006   0x20C0             MOVS     R0,#+192
   \   00000008   0x4020             ANDS     R0,R0,R4
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD103             BNE      ??RCC_ITConfig_0
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD103             BNE      ??RCC_ITConfig_1
   \                     ??RCC_ITConfig_0: (+1)
   \   00000016   0x....             LDR      R1,??DataTable37_6  ;; 0x56a
   \   00000018   0x....             LDR      R0,??DataTable37_1
   \   0000001A   0x.... 0x....      BL       assert_failed
   1387            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_ITConfig_1: (+1)
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD007             BEQ      ??RCC_ITConfig_2
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0xB2C0             UXTB     R0,R0
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD003             BEQ      ??RCC_ITConfig_2
   \   0000002E   0x....             LDR      R1,??DataTable37_7  ;; 0x56b
   \   00000030   0x....             LDR      R0,??DataTable37_1
   \   00000032   0x.... 0x....      BL       assert_failed
   1388            
   1389            if (NewState != DISABLE)
   \                     ??RCC_ITConfig_2: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD005             BEQ      ??RCC_ITConfig_3
   1390            {
   1391              /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
   1392              *(__IO uint8_t *) CIR_BYTE1_ADDRESS |= RCC_IT;
   \   0000003C   0x....             LDR      R0,??DataTable37_8  ;; 0x40021009
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0x4304             ORRS     R4,R4,R0
   \   00000042   0x....             LDR      R0,??DataTable37_8  ;; 0x40021009
   \   00000044   0x7004             STRB     R4,[R0, #+0]
   \   00000046   0xE004             B        ??RCC_ITConfig_4
   1393            }
   1394            else
   1395            {
   1396              /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
   1397              *(__IO uint8_t *) CIR_BYTE1_ADDRESS &= (uint8_t)~RCC_IT;
   \                     ??RCC_ITConfig_3: (+1)
   \   00000048   0x....             LDR      R0,??DataTable37_8  ;; 0x40021009
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x43A0             BICS     R0,R0,R4
   \   0000004E   0x....             LDR      R1,??DataTable37_8  ;; 0x40021009
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   1398            }
   1399          }
   \                     ??RCC_ITConfig_4: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1400          
   1401          /**
   1402            * @brief  Checks whether the specified RCC flag is set or not.
   1403            * @param  RCC_FLAG: specifies the flag to check.
   1404            *         This parameter can be one of the following values:
   1405            *             @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready  
   1406            *             @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   1407            *             @arg RCC_FLAG_PLLRDY: PLL clock ready
   1408            *             @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   1409            *             @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   1410            *             @arg RCC_FLAG_OBLRST: Option Byte Loader (OBL) reset 
   1411            *             @arg RCC_FLAG_PINRST: Pin reset
   1412            *             @arg RCC_FLAG_PORRST: POR/PDR reset
   1413            *             @arg RCC_FLAG_SFTRST: Software reset
   1414            *             @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   1415            *             @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   1416            *             @arg RCC_FLAG_LPWRRST: Low Power reset
   1417            *             @arg RCC_FLAG_HSI14RDY: HSI14 oscillator clock ready  
   1418            * @retval The new state of RCC_FLAG (SET or RESET).
   1419            */

   \                                 In section .text, align 2, keep-with-next
   1420          FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
   1421          {
   \                     RCC_GetFlagStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1422            uint32_t tmp = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   1423            uint32_t statusreg = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   1424            FlagStatus bitstatus = RESET;
   \   00000008   0x2000             MOVS     R0,#+0
   1425          
   1426            /* Check the parameters */
   1427            assert_param(IS_RCC_FLAG(RCC_FLAG));
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD033             BEQ      ??RCC_GetFlagStatus_0
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2811             CMP      R0,#+17
   \   00000018   0xD02F             BEQ      ??RCC_GetFlagStatus_0
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0x2819             CMP      R0,#+25
   \   00000020   0xD02B             BEQ      ??RCC_GetFlagStatus_0
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x2821             CMP      R0,#+33
   \   00000028   0xD027             BEQ      ??RCC_GetFlagStatus_0
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0x2841             CMP      R0,#+65
   \   00000030   0xD023             BEQ      ??RCC_GetFlagStatus_0
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0x2859             CMP      R0,#+89
   \   00000038   0xD01F             BEQ      ??RCC_GetFlagStatus_0
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xB2C0             UXTB     R0,R0
   \   0000003E   0x285A             CMP      R0,#+90
   \   00000040   0xD01B             BEQ      ??RCC_GetFlagStatus_0
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xB2C0             UXTB     R0,R0
   \   00000046   0x285B             CMP      R0,#+91
   \   00000048   0xD017             BEQ      ??RCC_GetFlagStatus_0
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0xB2C0             UXTB     R0,R0
   \   0000004E   0x285C             CMP      R0,#+92
   \   00000050   0xD013             BEQ      ??RCC_GetFlagStatus_0
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x285D             CMP      R0,#+93
   \   00000058   0xD00F             BEQ      ??RCC_GetFlagStatus_0
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0xB2C0             UXTB     R0,R0
   \   0000005E   0x285E             CMP      R0,#+94
   \   00000060   0xD00B             BEQ      ??RCC_GetFlagStatus_0
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0xB2C0             UXTB     R0,R0
   \   00000066   0x285F             CMP      R0,#+95
   \   00000068   0xD007             BEQ      ??RCC_GetFlagStatus_0
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0xB2C0             UXTB     R0,R0
   \   0000006E   0x2861             CMP      R0,#+97
   \   00000070   0xD003             BEQ      ??RCC_GetFlagStatus_0
   \   00000072   0x....             LDR      R1,??DataTable37_9  ;; 0x593
   \   00000074   0x....             LDR      R0,??DataTable37_1
   \   00000076   0x.... 0x....      BL       assert_failed
   1428          
   1429            /* Get the RCC register index */
   1430            tmp = RCC_FLAG >> 5;
   \                     ??RCC_GetFlagStatus_0: (+1)
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0xB2C0             UXTB     R0,R0
   \   0000007E   0x0940             LSRS     R0,R0,#+5
   \   00000080   0xB2C0             UXTB     R0,R0
   1431          
   1432            if (tmp == 0)               /* The flag to check is in CR register */
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD102             BNE      ??RCC_GetFlagStatus_1
   1433            {
   1434              statusreg = RCC->CR;
   \   00000086   0x....             LDR      R0,??DataTable37_10  ;; 0x40021000
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0xE00B             B        ??RCC_GetFlagStatus_2
   1435            }
   1436            else if (tmp == 1)          /* The flag to check is in BDCR register */
   \                     ??RCC_GetFlagStatus_1: (+1)
   \   0000008C   0x2801             CMP      R0,#+1
   \   0000008E   0xD102             BNE      ??RCC_GetFlagStatus_3
   1437            {
   1438              statusreg = RCC->BDCR;
   \   00000090   0x....             LDR      R0,??DataTable37_11  ;; 0x40021020
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0xE006             B        ??RCC_GetFlagStatus_2
   1439            }
   1440            else if (tmp == 2)          /* The flag to check is in CSR register */
   \                     ??RCC_GetFlagStatus_3: (+1)
   \   00000096   0x2802             CMP      R0,#+2
   \   00000098   0xD102             BNE      ??RCC_GetFlagStatus_4
   1441            {
   1442              statusreg = RCC->CSR;
   \   0000009A   0x....             LDR      R0,??DataTable37_12  ;; 0x40021024
   \   0000009C   0x6801             LDR      R1,[R0, #+0]
   \   0000009E   0xE001             B        ??RCC_GetFlagStatus_2
   1443            }
   1444            else                        /* The flag to check is in CR2 register */
   1445            {
   1446              statusreg = RCC->CR2;
   \                     ??RCC_GetFlagStatus_4: (+1)
   \   000000A0   0x....             LDR      R0,??DataTable37_13  ;; 0x40021034
   \   000000A2   0x6801             LDR      R1,[R0, #+0]
   1447            }    
   1448          
   1449            /* Get the flag position */
   1450            tmp = RCC_FLAG & FLAG_MASK;
   \                     ??RCC_GetFlagStatus_2: (+1)
   \   000000A4   0xB2E4             UXTB     R4,R4
   \   000000A6   0x06E0             LSLS     R0,R4,#+27       ;; ZeroExtS R0,R4,#+27,#+27
   \   000000A8   0x0EC0             LSRS     R0,R0,#+27
   1451          
   1452            if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
   \   000000AA   0x40C1             LSRS     R1,R1,R0
   \   000000AC   0x07C8             LSLS     R0,R1,#+31
   \   000000AE   0xD501             BPL      ??RCC_GetFlagStatus_5
   1453            {
   1454              bitstatus = SET;
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xE000             B        ??RCC_GetFlagStatus_6
   1455            }
   1456            else
   1457            {
   1458              bitstatus = RESET;
   \                     ??RCC_GetFlagStatus_5: (+1)
   \   000000B4   0x2000             MOVS     R0,#+0
   1459            }
   1460            /* Return the flag status */
   1461            return bitstatus;
   \                     ??RCC_GetFlagStatus_6: (+1)
   \   000000B6   0xB2C0             UXTB     R0,R0
   \   000000B8   0xBD10             POP      {R4,PC}          ;; return
   1462          }
   1463          
   1464          /**
   1465            * @brief  Clears the RCC reset flags.
   1466            *         The reset flags are: RCC_FLAG_OBLRST, RCC_FLAG_PINRST, RCC_FLAG_PORRST, 
   1467            *         RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST.
   1468            * @param  None
   1469            * @retval None
   1470            */

   \                                 In section .text, align 2, keep-with-next
   1471          void RCC_ClearFlag(void)
   1472          {
   1473            /* Set RMVF bit to clear the reset flags */
   1474            RCC->CSR |= RCC_CSR_RMVF;
   \                     RCC_ClearFlag: (+1)
   \   00000000   0x....             LDR      R0,??DataTable37_12  ;; 0x40021024
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2180             MOVS     R1,#+128
   \   00000006   0x0449             LSLS     R1,R1,#+17       ;; #+16777216
   \   00000008   0x4301             ORRS     R1,R1,R0
   \   0000000A   0x....             LDR      R0,??DataTable37_12  ;; 0x40021024
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   1475          }
   \   0000000E   0x4770             BX       LR               ;; return
   1476          
   1477          /**
   1478            * @brief  Checks whether the specified RCC interrupt has occurred or not.
   1479            * @param  RCC_IT: specifies the RCC interrupt source to check.
   1480            *         This parameter can be one of the following values:
   1481            *             @arg RCC_IT_LSIRDY: LSI ready interrupt
   1482            *             @arg RCC_IT_LSERDY: LSE ready interrupt
   1483            *             @arg RCC_IT_HSIRDY: HSI ready interrupt
   1484            *             @arg RCC_IT_HSERDY: HSE ready interrupt
   1485            *             @arg RCC_IT_PLLRDY: PLL ready interrupt
   1486            *             @arg RCC_IT_HSI14RDY: HSI14 ready interrupt 
   1487            *             @arg RCC_IT_CSS: Clock Security System interrupt
   1488            * @retval The new state of RCC_IT (SET or RESET).
   1489            */

   \                                 In section .text, align 2, keep-with-next
   1490          ITStatus RCC_GetITStatus(uint8_t RCC_IT)
   1491          {
   \                     RCC_GetITStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1492            ITStatus bitstatus = RESET;
   \   00000004   0x2000             MOVS     R0,#+0
   1493            
   1494            /* Check the parameters */
   1495            assert_param(IS_RCC_GET_IT(RCC_IT));
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD01B             BEQ      ??RCC_GetITStatus_0
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xD017             BEQ      ??RCC_GetITStatus_0
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xD013             BEQ      ??RCC_GetITStatus_0
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0x2808             CMP      R0,#+8
   \   00000024   0xD00F             BEQ      ??RCC_GetITStatus_0
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xB2C0             UXTB     R0,R0
   \   0000002A   0x2810             CMP      R0,#+16
   \   0000002C   0xD00B             BEQ      ??RCC_GetITStatus_0
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0xB2C0             UXTB     R0,R0
   \   00000032   0x2820             CMP      R0,#+32
   \   00000034   0xD007             BEQ      ??RCC_GetITStatus_0
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0xB2C0             UXTB     R0,R0
   \   0000003A   0x2880             CMP      R0,#+128
   \   0000003C   0xD003             BEQ      ??RCC_GetITStatus_0
   \   0000003E   0x....             LDR      R1,??DataTable37_14  ;; 0x5d7
   \   00000040   0x....             LDR      R0,??DataTable37_1
   \   00000042   0x.... 0x....      BL       assert_failed
   1496            
   1497            /* Check the status of the specified RCC interrupt */
   1498            if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
   \                     ??RCC_GetITStatus_0: (+1)
   \   00000046   0x....             LDR      R0,??DataTable37_15  ;; 0x40021008
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xB2E4             UXTB     R4,R4
   \   0000004C   0x4004             ANDS     R4,R4,R0
   \   0000004E   0x2C00             CMP      R4,#+0
   \   00000050   0xD001             BEQ      ??RCC_GetITStatus_1
   1499            {
   1500              bitstatus = SET;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE000             B        ??RCC_GetITStatus_2
   1501            }
   1502            else
   1503            {
   1504              bitstatus = RESET;
   \                     ??RCC_GetITStatus_1: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   1505            }
   1506            /* Return the RCC_IT status */
   1507            return  bitstatus;
   \                     ??RCC_GetITStatus_2: (+1)
   \   00000058   0xB2C0             UXTB     R0,R0
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
   1508          }
   1509          
   1510          /**
   1511            * @brief  Clears the RCC's interrupt pending bits.
   1512            * @param  RCC_IT: specifies the interrupt pending bit to clear.
   1513            *         This parameter can be any combination of the following values:
   1514            *             @arg RCC_IT_LSIRDY: LSI ready interrupt
   1515            *             @arg RCC_IT_LSERDY: LSE ready interrupt
   1516            *             @arg RCC_IT_HSIRDY: HSI ready interrupt
   1517            *             @arg RCC_IT_HSERDY: HSE ready interrupt
   1518            *             @arg RCC_IT_PLLRDY: PLL ready interrupt
   1519            *             @arg RCC_IT_HSI14RDY: HSI14 ready interrupt  
   1520            *             @arg RCC_IT_CSS: Clock Security System interrupt
   1521            * @retval None
   1522            */

   \                                 In section .text, align 2, keep-with-next
   1523          void RCC_ClearITPendingBit(uint8_t RCC_IT)
   1524          {
   \                     RCC_ClearITPendingBit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1525            /* Check the parameters */
   1526            assert_param(IS_RCC_CLEAR_IT(RCC_IT));
   \   00000004   0x0660             LSLS     R0,R4,#+25
   \   00000006   0xD403             BMI      ??RCC_ClearITPendingBit_0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD103             BNE      ??RCC_ClearITPendingBit_1
   \                     ??RCC_ClearITPendingBit_0: (+1)
   \   00000010   0x....             LDR      R1,??DataTable37_16  ;; 0x5f6
   \   00000012   0x....             LDR      R0,??DataTable37_1
   \   00000014   0x.... 0x....      BL       assert_failed
   1527            
   1528            /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
   1529               pending bits */
   1530            *(__IO uint8_t *) CIR_BYTE2_ADDRESS = RCC_IT;
   \                     ??RCC_ClearITPendingBit_1: (+1)
   \   00000018   0x....             LDR      R0,??DataTable37_17  ;; 0x4002100a
   \   0000001A   0x7004             STRB     R4,[R0, #+0]
   1531          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x40021004         DC32     0x40021004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0xF8FFB80C         DC32     0xf8ffb80c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0xFEF6FFFF         DC32     0xfef6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0xFFFBFFFF         DC32     0xfffbffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xFFC0FFFF         DC32     0xffc0ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x4002102C         DC32     0x4002102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40021030         DC32     0x40021030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0xFFFFFEAC         DC32     0xfffffeac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40021034         DC32     0x40021034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x40021008         DC32     0x40021008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x40021002         DC32     0x40021002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x40021020         DC32     0x40021020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40021024         DC32     0x40021024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0xFFC2FFFF         DC32     0xffc2ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0xFEFFFFFF         DC32     0xfeffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x40021004         DC32     0x40021004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x00000212         DC32     0x212

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x4002102C         DC32     0x4002102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x0000022B         DC32     0x22b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0xFFF7FFFF         DC32     0xfff7ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0x00000247         DC32     0x247

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \   00000000   0x40021007         DC32     0x40021007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \   00000000   0x000002B2         DC32     0x2b2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \   00000000   0x000002E3         DC32     0x2e3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x00000302         DC32     0x302

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0xFFFFF8FF         DC32     0xfffff8ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x40021004         DC32     0x40021004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x01004000         DC32     0x1004000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x0000031D         DC32     0x31d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0xFFFFBFFF         DC32     0xffffbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0xFFFFFEFF         DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x00000336         DC32     0x336

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x40021030         DC32     0x40021030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x0000034A         DC32     0x34a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x005B8D80         DC32     0x5b8d80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x003D0900         DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x40021030         DC32     0x40021030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x4002102C         DC32     0x4002102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x........         DC32     APBAHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0x00D59F80         DC32     0xd59f80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0x00008012         DC32     0x8012

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x0000043D         DC32     0x43d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x0000044E         DC32     0x44e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \   00000000   0xFFFF7FFF         DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \   00000000   0x00000465         DC32     0x465

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x40021020         DC32     0x40021020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0xFFFEFFFF         DC32     0xfffeffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0xFEA1FFAA         DC32     0xfea1ffaa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0x00000489         DC32     0x489

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \   00000000   0x0000048A         DC32     0x48a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   0x40021014         DC32     0x40021014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_1:
   \   00000000   0xFFB8A5FE         DC32     0xffb8a5fe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_2:
   \   00000000   0x000004AD         DC32     0x4ad

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_3:
   \   00000000   0x000004AE         DC32     0x4ae

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_4:
   \   00000000   0x8F9DB6EC         DC32     0x8f9db6ec

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_5:
   \   00000000   0x000004D4         DC32     0x4d4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_6:
   \   00000000   0x000004D5         DC32     0x4d5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x40021018         DC32     0x40021018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \   00000000   0x4002101C         DC32     0x4002101c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_2:
   \   00000000   0xFEA1FFFF         DC32     0xfea1ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_3:
   \   00000000   0x000004F2         DC32     0x4f2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_4:
   \   00000000   0x000004F3         DC32     0x4f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x00000513         DC32     0x513

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0x40021028         DC32     0x40021028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_2:
   \   00000000   0x00000514         DC32     0x514

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_3:
   \   00000000   0x4002100C         DC32     0x4002100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_4:
   \   00000000   0x00000537         DC32     0x537

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_5:
   \   00000000   0x40021010         DC32     0x40021010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_6:
   \   00000000   0x0000056A         DC32     0x56a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_7:
   \   00000000   0x0000056B         DC32     0x56b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_8:
   \   00000000   0x40021009         DC32     0x40021009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_9:
   \   00000000   0x00000593         DC32     0x593

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_10:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_11:
   \   00000000   0x40021020         DC32     0x40021020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_12:
   \   00000000   0x40021024         DC32     0x40021024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_13:
   \   00000000   0x40021034         DC32     0x40021034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_14:
   \   00000000   0x000005D7         DC32     0x5d7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_15:
   \   00000000   0x40021008         DC32     0x40021008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_16:
   \   00000000   0x000005F6         DC32     0x5f6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_17:
   \   00000000   0x4002100A         DC32     0x4002100a

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 49H, 6CH, 79H, 61H, 5CH
   \              0x5C 0x49    
   \              0x6C 0x79    
   \              0x61 0x5C    
   \   00000008   0x50 0x72          DC8 50H, 72H, 6FH, 6AH, 65H, 63H, 74H, 73H
   \              0x6F 0x6A    
   \              0x65 0x63    
   \              0x74 0x73    
   \   00000010   0x5C 0x33          DC8 5CH, 33H, 33H, 32H, 20H, 57H, 53H, 32H
   \              0x33 0x32    
   \              0x20 0x57    
   \              0x53 0x32    
   \   00000018   0x38 0x31          DC8 38H, 31H, 31H, 20H, 68H, 65H, 77H, 20H
   \              0x31 0x20    
   \              0x68 0x65    
   \              0x77 0x20    
   \   00000020   0x79 0x65          DC8 79H, 65H, 61H, 72H, 20H, 6CH, 69H, 67H
   \              0x61 0x72    
   \              0x20 0x6C    
   \              0x69 0x67    
   \   00000028   0x68 0x74          DC8 68H, 74H, 5CH, 49H, 41H, 52H, 5CH, 43H
   \              0x5C 0x49    
   \              0x41 0x52    
   \              0x5C 0x43    
   \   00000030   0x4D 0x53          DC8 4DH, 53H, 49H, 53H, 5CH, 73H, 74H, 6DH
   \              0x49 0x53    
   \              0x5C 0x73    
   \              0x74 0x6D    
   \   00000038   0x33 0x32          DC8 33H, 32H, 66H, 30H, 78H, 78H, 5FH, 72H
   \              0x66 0x30    
   \              0x78 0x78    
   \              0x5F 0x72    
   \   00000040   0x63 0x63          DC8 63H, 63H, 2EH, 63H, 0
   \              0x2E 0x63    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1532          
   1533          /**
   1534            * @}
   1535            */
   1536          
   1537          /**
   1538            * @}
   1539            */
   1540          
   1541          /**
   1542            * @}
   1543            */
   1544          
   1545          /**
   1546            * @}
   1547            */
   1548          
   1549          /******************* (C) COPYRIGHT 2012 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   RCC_ADCCLKConfig
         8   -> assert_failed
      16   RCC_AHBPeriphClockCmd
        16   -> assert_failed
      16   RCC_AHBPeriphResetCmd
        16   -> assert_failed
      16   RCC_APB1PeriphClockCmd
        16   -> assert_failed
      16   RCC_APB1PeriphResetCmd
        16   -> assert_failed
      16   RCC_APB2PeriphClockCmd
        16   -> assert_failed
      16   RCC_APB2PeriphResetCmd
        16   -> assert_failed
       8   RCC_AdjustHSI14CalibrationValue
         8   -> assert_failed
       8   RCC_AdjustHSICalibrationValue
         8   -> assert_failed
       8   RCC_BackupResetCmd
         8   -> assert_failed
       8   RCC_CECCLKConfig
         8   -> assert_failed
       0   RCC_ClearFlag
       8   RCC_ClearITPendingBit
         8   -> assert_failed
       8   RCC_ClockSecuritySystemCmd
         8   -> assert_failed
       0   RCC_DeInit
      12   RCC_GetClocksFreq
        12 __aeabi_uidiv
       8   RCC_GetFlagStatus
         8   -> assert_failed
       8   RCC_GetITStatus
         8   -> assert_failed
       0   RCC_GetSYSCLKSource
       8   RCC_HCLKConfig
         8   -> assert_failed
       8   RCC_HSEConfig
         8   -> assert_failed
       8   RCC_HSI14ADCRequestCmd
         8   -> assert_failed
       8   RCC_HSI14Cmd
         8   -> assert_failed
       8   RCC_HSICmd
         8   -> assert_failed
       8   RCC_I2CCLKConfig
         8   -> assert_failed
      16   RCC_ITConfig
        16   -> assert_failed
       8   RCC_LSEConfig
         8   -> assert_failed
       8   RCC_LSEDriveConfig
         8   -> assert_failed
       8   RCC_LSICmd
         8   -> assert_failed
       8   RCC_MCOConfig
         8   -> assert_failed
       8   RCC_PCLKConfig
         8   -> assert_failed
       8   RCC_PLLCmd
         8   -> assert_failed
      16   RCC_PLLConfig
        16   -> assert_failed
       8   RCC_PREDIV1Config
         8   -> assert_failed
       8   RCC_RTCCLKCmd
         8   -> assert_failed
       8   RCC_RTCCLKConfig
         8   -> assert_failed
       8   RCC_SYSCLKConfig
         8   -> assert_failed
       8   RCC_USARTCLKConfig
         8   -> assert_failed
       8   RCC_WaitForHSEStartUp
         8   -> RCC_GetFlagStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_2
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_2
       4  ??DataTable33_3
       4  ??DataTable33_4
       4  ??DataTable33_5
       4  ??DataTable33_6
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_2
       4  ??DataTable35_3
       4  ??DataTable35_4
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_10
       4  ??DataTable37_11
       4  ??DataTable37_12
       4  ??DataTable37_13
       4  ??DataTable37_14
       4  ??DataTable37_15
       4  ??DataTable37_16
       4  ??DataTable37_17
       4  ??DataTable37_2
       4  ??DataTable37_3
       4  ??DataTable37_4
       4  ??DataTable37_5
       4  ??DataTable37_6
       4  ??DataTable37_7
       4  ??DataTable37_8
       4  ??DataTable37_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
      72  ?_0
      16  APBAHBPrescTable
      80  RCC_ADCCLKConfig
      80  RCC_AHBPeriphClockCmd
      80  RCC_AHBPeriphResetCmd
      80  RCC_APB1PeriphClockCmd
      82  RCC_APB1PeriphResetCmd
      80  RCC_APB2PeriphClockCmd
      80  RCC_APB2PeriphResetCmd
      44  RCC_AdjustHSI14CalibrationValue
      44  RCC_AdjustHSICalibrationValue
      64  RCC_BackupResetCmd
      44  RCC_CECCLKConfig
      16  RCC_ClearFlag
      30  RCC_ClearITPendingBit
      64  RCC_ClockSecuritySystemCmd
     104  RCC_DeInit
     300  RCC_GetClocksFreq
     186  RCC_GetFlagStatus
      92  RCC_GetITStatus
      10  RCC_GetSYSCLKSource
      66  RCC_HCLKConfig
      48  RCC_HSEConfig
      64  RCC_HSI14ADCRequestCmd
      64  RCC_HSI14Cmd
      64  RCC_HSICmd
      44  RCC_I2CCLKConfig
      84  RCC_ITConfig
      62  RCC_LSEConfig
      54  RCC_LSEDriveConfig
      64  RCC_LSICmd
      66  RCC_MCOConfig
      66  RCC_PCLKConfig
      66  RCC_PLLCmd
     180  RCC_PLLConfig
      94  RCC_PREDIV1Config
      64  RCC_RTCCLKCmd
      48  RCC_RTCCLKConfig
      42  RCC_SYSCLKConfig
      54  RCC_USARTCLKConfig
      58  RCC_WaitForHSEStartUp

 
    16 bytes in section .data
    72 bytes in section .rodata
 3 264 bytes in section .text
 
 3 264 bytes of CODE  memory
    72 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
